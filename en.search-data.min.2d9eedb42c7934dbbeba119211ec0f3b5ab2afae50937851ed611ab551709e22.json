[{"id":0,"href":"/docs/03.eca-rules/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/","title":"基础相关","section":"三. Eca Rules","content":"表达式 #   针对每个规则，都实现了表达式\n 变量表达式 #     变量 作用 是否允许业务扩展     $root 根节点 ❌   $current 当前节点 ❌   $parent 父节点 ❌   $context 上下文，由场景方案具体指定有哪些属性，通常不允许业务扩展 ❌   $params 参数，通常业务扩展参数定义在这里 ✅   $fn 表达式函数，允许业务扩展 ✅    节点选择器 #  根节点 $root #   来获取当前规则所绑定的节点的根节点。\n ❗❗❗ 注意，不同规则可以绑定在不同节点上，但它们根节点因该相同\n详细文档请参考 http://front.q7link.com:3000/docs/biz-rules/docs/eca-rules/get-started/using-expr/using-reference\n上下文 $context #   上下文通常指的是在一个技术方案中，由技术方案本身提供的上下文变量，不支持业务扩展。\n    变量 作用     $context.mode 当前表单模式，Create：新增、Edit：编辑、Copy：复制、Generate：生单、View：查看   $context.isMobile 是否是移动端   $context.entityName 当前业务对象实体名称   $context.isEnabledMultiOrg 是否启用多组织   $context.businessDate 业务日期（deprecated）    表达式传参 $params #   参数通常是由业务自定义，当遇到复杂逻辑，不好用表达式直接实现的，可以本地代码中计算完成后，在放入 $params 中。待平台更新文档\n 表达式函数 $fn #   表达式函数中，会包含平台内置函数，且允许业务进行扩展。\n 1.内置函数 #     函数 作用     $fn.getEnumValue(enumValue: string): IEnumValue 传入 enumValue.id，返回一个枚举结构化对象   $fn.getBusinessType(id: string): IBusinessType 传入 businessTypeId，返回一个 IBusinessType 结构化对象   $fn.getObjectType(id: string): IObjectType 传入 entityName，返回一个 IObjectType 结构化对象   $fn.sum(...numbers: number[]): number 加法运算   $fn.subtract(...numbers: number[]): number 减法运算   $fn.multiply(...numbers: number[]): number 乘法运算   $fn.divide(...numbers: number[]): number 除法运算    2.函数的构成 #      是否必填 备注     函数名 是 由小写或大写字母构成   描述信息 是 描述功能的文字信息   函数类型申明 否 在函数代码中申明即可(未申明则自动分析函数生成)   默认导出函数 是 必须由export default导出函数   规则执行函数 是 必须返回规则执行函数    3. 函数公共API #      示例 备注     form.select api.form.select('code') 查询表单字段返回该字段的多种状态与值   form.getValue api.getValue('code') 查询表单中某个字段的值   fn api.fn.xxx() 调用其他公共函数(如：内置函数/引用函数/同一规则组内的函数    "},{"id":1,"href":"/docs/01.base/%E5%88%9D%E5%85%A5%E6%96%B0%E6%89%8B%E6%9D%91/","title":"初入新手村","section":"一. 前端框架基础","content":"一、VPN #   申请vpn    等陈欢（欢姐）把vpn的证书发过来。\n  安装openvpn，应用证书。\n  二、安装环境 #  注意事项：\n go环境的目录结构，GOROOT/src/ metadata项目的名字，git仓库名和本地文件名不一样 go的证书  "},{"id":2,"href":"/docs/04.gql/gql/","title":"GQL基础","section":"四. Gql相关查询","content":"普通的gql #  最简单的，直接查一个对象（表）的全部数据\n{ BudgetAccount{ id name accountType { id name } } } 加一点查询条件\n{ BudgetAccount(criteriaStr:\u0026quot;name in ('1','2','3')\u0026quot;){ id name accountType { id name } } } 这个会查到name为1、2、3的多条数据\n常用的 gql 查询语句 #  1. 查看某种业务对象的实体名 #  // 例如出入库业务 ObjectType(criteriaStr: \u0026quot;appName='inventory'\u0026quot;) { id title } 2. 查询预制列表组 #  // 例如公告列表组 QueryDefinitionGroup(criteriaStr:\u0026quot;objectType='Notice'\u0026quot;){ id objectType title } 3. 预制列表方案 #  // 例如公告列表方案 QueryListDefinition(criteriaStr:\u0026quot;objectType='Notice'\u0026quot;){ id objectType title } 高级的gql #  上面只能查到一个表的数据及其关联的外键，子表的数据。下面来搞一个子查询。\n 因为有的时候，后端的模型中，没有包含我们需要的子表，只能我们自己构建\n { BudgetAccount(criteriaStr:\u0026quot;\u0026quot;){ a: exprField(expr:\u0026quot;()\u0026quot;) b: exprField(expr:\u0026quot;()\u0026quot;) } } 其中a:是个模型上的一个字段起别名，exprField是一个可以扩展的额外字段，利用这两个就可以做成子查询了。\n举个例子。对于预算指标，复合指标有若干个子指标，但是直接通过BudgetIndicator模型获取不到它们。就可以这样做\n{ BudgetIndicator(criteriaStr:\u0026quot;isComposite=true\u0026quot;){ id isComposite child: exprField(expr:\u0026quot;(select string_agg(CONCAT_WS(',',childIndicator.id,childIndicator.name),';') from BudgetIndicatorComposition where parentIndicatorId=m.id)\u0026quot;) } } 这里使用了两个sql函数把多条记录、多个字段组合成了一个字符串。拿到数据后前端经过简单的split转化就可以拿到json对象了。\n常用的sql函数 #  string_agg: 如果查出来有多条结果，会将它们拼装为一个字符串\n例子：string_agg(object.name, ', ')\ncoalesce：如果alias存在则取alias，不存在取name\n例子：string_agg((coalesce(indicator.alias, indicator.name)), ', ')\nconcat_ws：拼装一条记录的多个字段为一个字段\n例子：string_agg(CONCAT_WS(',',childIndicator.id,childIndicator.name),';')\nDataLoader #  const settingDataLoader = new DataLoader(EN_Setting, [\u0026#39;values.value\u0026#39;], { criteriaStr: `key=\u0026#39;${accountingBook}\u0026#39;`, } as QueryOptions); const ret = await settingDataLoader.query(); 不适用DataLoader，直接使用gql #  import client from \u0026#39;@client\u0026#39;; const fetchControlBalance = async (criteriaStr: string, dimensionField: string[]) =\u0026gt; { const res = await client.query\u0026lt;{ data: Array\u0026lt;IInvoiceType\u0026gt; }\u0026gt;({ query: ` { data: BudgetControlBalance(criteriaStr: \u0026#34;${criteriaStr}\u0026#34;){ id } } `, }); return res.data.data }; Go怎么查GQL #  func GetFieldMapping(c context.TrekContext, billClassId string) []Mapping { queryString := `{ BudgetDimensionFieldMapping(criteriaStr:\u0026#34;billClassId = \u0026#39;{{.billClassId}}\u0026#39; and dimensionId = \u0026#39;FinancialOrg\u0026#39;\u0026#34;){ mappingToWhereId mappingField } }` query := graphql.GraphqlTemplate(queryString, map[string]string{ \u0026#34;billClassId\u0026#34;: billClassId, }) data := map[string]interface{}{ \u0026#34;query\u0026#34;: query, } var dataJson FieldMappingRes context.HttpRequest.DoHTTPPost(c, urls.AppGraphQL, \u0026amp;context.HTTPOptions{ BindBody: \u0026amp;dataJson, ParamStruct: \u0026amp;data, }) return dataJson.Data.BudgetDimensionFieldMapping } type Mapping struct { MappingToWhereId string `json:\u0026#34;mappingToWhereId\u0026#34;` MappingField string `json:\u0026#34;mappingField\u0026#34;` } type FieldMappingRes struct { Data struct { BudgetDimensionFieldMapping []Mapping `json:\u0026#34;BudgetDimensionFieldMapping\u0026#34;` } `json:\u0026#34;data\u0026#34;` Errors []interface{} `json:\u0026#34;errors\u0026#34;` }  queryString定义语句的模板，其中可以包含一些模板变量 GraphqlTemplate将模板变量引用到模板 用DoHTTPPost发起请求  "},{"id":3,"href":"/docs/04.gql/%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2/","title":"常用查询","section":"四. Gql相关查询","content":"查找已存在的列表组 #  QueryDefinitionGroup(criteriaStr:\u0026#34;name like \u0026#39;%Misc%\u0026#39;\u0026#34;){ id name objectType } 查找老列表方案 #  { UiConfig(criteriaStr:\u0026#34;type=\u0026#39;listSolution\u0026#39;\u0026#34;){ name } } "},{"id":4,"href":"/docs/02.form/bizfirmpageapi/","title":"BizFirmPageApi","section":"二. BizForm基础","content":"authController: 权限控制器 #  authController.actionId // 权限行为动作id  authController.resourceId // 资源id  authController.setResourceId // 设置资源id  authController.checkAuth // 权限校验  authController.checkAuthWithData // 校验数据权限  authController.backViewMode // 返回查看态 createMasterCriteriaRaction: #  criteriaController: #  criteriaController.createCriteriaStrReaction(path, producer, fireImmediately) // 设置字段查询参数 criteriaController.createCriteriaReaction(path, producer, fireImmediately) criteriaController.createDetailCriteriaStrReaction(rowField, subpath, producer, fireImmediately) criteriaController.createDetailCriteriaReaction criteriaController.getDetailCriteriaStr(rowField, fieldName) // 获取子表字段查询参数 criteriaController.getDetailBindVars(rowField, fieldName) // 获取子表字段 bindvar 变量 criteriaController.getCriteriaStr(path) // 获取字段查询参数 criteriaController.getBindVars(path) // 获取字段bindvar 变量 defaultValueController #  detailController #  detailDefaultController #  detailEnricherController #  ecaLogController #  eventController #  fieldAuthController #  fieldComponentPropsController #  formController #  formRuntimeController #  initialController #  masterController #  masterRendererController #  menuController #  paramsController #  polymorphicRenderController #  rangeWalkController #  reactionScenariosController #  sectionController #  stateController #  StateController.billStatus //单据状态 StateController.mode //单据模式 tabApi #  tabApi.changeTitle() // 变更标签 title tabApi.changePath // 变更页面路由 tabApi.closeTab() // 关闭标签 tabApi.showLoading() // 显示页面加载loading状态 tabApi.hideLoading() // 隐藏页面加载loading状态 tabApi.getInstance tabApi.getParams() // 获取路由params tabApi.getTitle // 获取当前标签栏titile tabApi.getUrlParams() // 获取路由url参数 tabApi.isActive // 当前标签栏是否激活 tabApi.isClosed // 当前标签栏是否关闭 tabApi.whenActive(callback) // 当标签页激活状态时 tabApi.whenDeactive(callback) // tabApi.whenClosed(callback) // 当当标签栏关闭时触发 tabApi.whenRefresh(callback) // 当页面刷新时触发 tabTitleController // 标签栏控制器 #  tabTitleController.setTabTitle() // 设置标签栏 title "},{"id":5,"href":"/docs/06.list-guide/controller/","title":"Controller","section":"六. 列表方案攻略","content":"listSolutionConnector #  获取当前列表展示项实体名（子表/整单）：listSolutionConnector.masterEntityName 获取当前列表主表实体名（entityName） listSolutionConnector.entityName\nformController #  获取视图中的数据: formController.getView('xxx')\n"},{"id":6,"href":"/docs/12.go/basics/","title":"Basics","section":"12.go","content":"系统参数获取 #  formContext.GetContext().GetSystemSettingService().GetSettingValueByKey(\u0026#34;isEnableBatch\u0026#34;, \u0026#34;\u0026#34;) "},{"id":7,"href":"/docs/11.regexp/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99/","title":"常用正则","section":"十一. 正则","content":"查询表单模版中重复的子表字段 #  (\u0026#34;path\u0026#34;: \u0026#34;.*s\u0026#34;)[\\w\\W]{0,1000}\\1 "},{"id":8,"href":"/docs/03.eca-rules/%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99/","title":"常用规则","section":"三. Eca Rules","content":"当一个字段变更时清空另一个字段 #  \u0026#34;id\u0026#34;: \u0026#34;3fed09f2-05e1-462f-8b95-a73b43ebd13e\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;调入组织切换时清空调入仓库\u0026#34;, \u0026#34;trigger\u0026#34;: { \u0026#34;event\u0026#34;: \u0026#34;Change\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;$current.inInventoryOrg\u0026#34; }, \u0026#34;condition\u0026#34;: { \u0026#34;if\u0026#34;: \u0026#34;true\u0026#34; }, \u0026#34;actions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Assignment\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;expr\u0026#34;: \u0026#34;undefined\u0026#34;, \u0026#34;field\u0026#34;: \u0026#34;inWarehouse\u0026#34; } } ] "},{"id":9,"href":"/docs/01.base/entity/","title":"模型、entity与元数据","section":"一. 前端框架基础","content":"模型 #  我们系统的后端是领域模型驱动的。比如下图是预算编制方案的模型，其中包含了很多实体(entity)(蓝色的)。 entity #  一个entity就是一个对象，可以通过模型看到各个属性的名字和类型，以及entity之间的关系。\n我们前端的工作就是为entity制作表单和列表，来创建entity的实例或展示entity的信息。\n元数据 #  前端的元数据主要是对entity的描述。entity的名字、entity的属性名、属性类型等等。\n"},{"id":10,"href":"/docs/01.base/%E9%A2%84%E7%BD%AE%E6%95%B0%E6%8D%AE/","title":"预置数据","section":"一. 前端框架基础","content":"什么是预置数据 #  预置数据可以理解为软件的出厂自带数据，当用户第一次拿到系统时，就存在于系统中的数据。\n在预置数据的基础上，用户可以对它们进行修改，也可以添加自己的数据。我们把修改和添加的数据叫做用户数据。\n系统中有很多种预置数据。\n比如，菜单、查询方案、列表方案\n用户可以自己新加几个菜单选项。可以修改查询方案中的字段。可以修改列表方案中显示的列、显示的宽度。等等\n预置数据与开发的关系 #  通常，预置数据都会在需求中提到，由产品提供。有些预置数据是后端直接放到数据库里的，前端通过gql取。还有一些是前端在前端开发包里面配置的，这就涉及到了查询方案、列表方案、参照、全局搜索、移动端模板等场景。\n将预置数据预置到系统中 #  开发预置的数据是在当前租户的或登录租户的。系统的其他租户是没有这份预置数据的。所以我们需要有一个将预置数据预置到系统中的操作。\n 记录一下自己预置了什么（表单、老列表、多列表） 把需要预置的数据的信息整理好，发给曾天保同学。其中几个信息如何获取会在下面介绍。  预置表单 环境: release 后端分支: release 预置租户: PSE5KP504EN000F 改了 Project 预置老列表 环境: test 后端分支: feature-budget-iteration-3rd 预置租户: A24SJR50KMK001E 改了 ProjectMemberView 预置多列表 环境: release 后端分支: release 登录租户id: NSKDNT50NVS002J 多列表方案名称: Project_list 预置租户id：在ops的环境信息中，各个环境都会有预置租户id 登录租户id：打开系统，打开开发者工具network，随便选一个请求，其中header中改回有一个租户id，这就是登陆租户id。 "},{"id":11,"href":"/docs/02.form/what-is-bizform/","title":"什么是BizForm","section":"二. BizForm基础","content":"Biz是业务的意思，Form是表单的意思，两个词组合起来就是业务表单。业务泛指我们系统要处理的各种业务，比如项目、报销、合同等等。表单比较常见，就是展示或者收集各种信息的页面。这些页面是由前端框架中的BizForm类实现的。\n先看一下我们系统中的表单长什么样。\n这是展示了一个编辑态和一个查看态。 这里只简单的看一个样子，其他文档会介绍更加详细的、各个状态、各个部分的内容。\n"},{"id":12,"href":"/docs/06.list-guide/%E7%A9%BF%E9%80%8F/","title":"穿透","section":"六. 列表方案攻略","content":"穿透 #  我比较喜欢叫它超链接，就是点击列表上的单元格会跳到其他页面的功能。\n在这里展示了两种需求：\n 会跳到当前单据类型（项目计划）的单据详情页 会跳到其他单据类型（项目）的单据详情页。  代码实现 #   使用rowActionController.makeRowEditAction  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class BudgetModelList extends QueryListPagePresenter { { protected getListOption(): IListOption { const listOption = super.getListOption(); return merge(listOption, { gridOption: { actionColumnOption: { visibleSize: 3, }, columnResolver: columnDefs =\u0026gt; { this.projectColumn(columnDefs); columnDefs.forEach(colDef =\u0026gt; { if ( (colDef.field === \u0026#39;code\u0026#39; || colDef.field === \u0026#39;name\u0026#39;) \u0026amp;\u0026amp; checkAuth(\u0026#39;BudgetModel\u0026#39;, FunctionAuthActionType.Update) ) { colDef.cellClass = \u0026#39;object-cell-linkable\u0026#39;; colDef.onCellClicked = event =\u0026gt; { const editAction = this.presenter.listSolutionConnector.rowActionController.makeRowEditAction( undefined, event.data, ); editAction.onClick(event.rowIndex, event.data); }; }  }); }, }, }); } }   其中的makeRowEditAction是去编辑态的单据，可以换成makeRowViewAction实现去查看态。\n用masterHashResolver这个api，可以指定跳转目标单据的entity。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class TaskPlanListPresenter extends QueryListPagePresenter { getListOption(): IListOption { return { ...super.getListOption(), gridOption: { columnResolver: columnDefs =\u0026gt; { // 将数组转化为map，这个可以不做，直接用find在数组中找到你想找的column  const columnDefsMap = new Map(); columnDefs.forEach(i =\u0026gt; { columnDefsMap.set(i.field, i); }) // 找到column  const projectCode = columnDefsMap.get(\u0026#39;project.code\u0026#39;); // 设置样式和点击事件  projectCode.cellClass = \u0026#39;object-cell-linkable\u0026#39;; projectCode.onCellClicked = event =\u0026gt; { // 实用列表方案的api来实现跳转  this.presenter.listSolutionConnector.rowActionController.masterHashResolver( {name: EN_Project} as Entity, BizListActionEnum.View, {id: event.data.project.id}, event.rowIndex, this.presenter.listSolutionConnector.rowActionController.saveSuccess, );  }; } } } } }   "},{"id":13,"href":"/docs/02.form/%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/","title":"BizForm的组成部分","section":"二. BizForm基础","content":"表单会有不同的状态。\n创建和修改时，表单是可以填写内容的，我们称之为编辑态。\n查看、审批时，不能编辑内容，只能看，我们称之为查看态。\n查看态 #   表单状态 异步任务异常 menu-buttons rang-walk 主表 审批流 子表 ？不知道  "},{"id":14,"href":"/docs/05.form-guide/","title":"五. BizForm实用攻略","section":"Docs","content":"注意： 单据设计默些字段无法展开时,注释掉以下代码刷新后重试。\n// *注释的代码别提交*  if (hasParent) { return field.properties.asCriteria; }  devs/query-list/components/list-columns-def/FieldSelectorDialogOptionBuilder.ts\n "},{"id":15,"href":"/docs/03.eca-rules/%E5%AD%97%E6%AE%B5%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95/","title":"字段状态方法","section":"三. Eca Rules","content":"字段方法 #     字段状态 表达式 备注     $focused 是否焦点 判断目标字段是否获取焦点   $disabled 是否禁用 判断当前字段是否禁用    "},{"id":16,"href":"/docs/03.eca-rules/%E5%8D%95%E6%8D%AE-%E6%A1%A3%E6%A1%88%E5%85%AC%E5%85%B1%E8%A7%84%E5%88%99%E5%BC%95%E5%85%A5/","title":"单据 档案公共规则引入","section":"三. Eca Rules","content":"档案公共包引入 #  \u0026#34;dependentPackageIds\u0026#34;: [ \u0026#34;3a061db3-ae38-4559-8cd3-aed0950c6a37\u0026#34; ] 单据公共包引入 #  \u0026#34;dependentPackageIds\u0026#34;: [ \u0026#34;af0f0b05-a736-46d9-8c17-97afd29b5f31\u0026#34; ] "},{"id":17,"href":"/docs/08.inventory/%E5%BA%93%E5%AD%98%E7%9B%B8%E5%85%B3%E5%AD%97%E6%AE%B5%E8%BF%87%E6%BB%A4eca-rules/","title":"库存相关字段过滤Eca Rules","section":"八. Inventory库存相关过滤字段","content":"1. 明细表存货字段参照过滤-基准类型为数量型 #    { \u0026#34;reference\u0026#34;: \u0026#34;miscReceiptItems\u0026#34;, \u0026#34;actions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ReactiveCriteria\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;存货参照过滤基准类型为数量型\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;product\u0026#34;, \u0026#34;fragment\u0026#34;: { \u0026#34;autoClear\u0026#34;: true, \u0026#34;criteriaStr\u0026#34;: \u0026#34;productStandardTypeId = \u0026#39;ProductStandardType.quantity\u0026#39;\u0026#34;, \u0026#34;fireImmediately\u0026#34;: true, \u0026#34;when\u0026#34;: \u0026#34;true\u0026#34; } } } ] } 2. 字段过滤透传props #  { \u0026#34;name\u0026#34;: \u0026#34;ReactiveFieldComponentProps\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;field: 出入库类型\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;stockTransType\u0026#34;, \u0026#34;effects\u0026#34;: [ { \u0026#34;props\u0026#34;: { \u0026#34;contextOrgIds\u0026#34;: \u0026#34;[$current.createdOrg.id]\u0026#34; }, \u0026#34;isDestruct\u0026#34;: false, \u0026#34;when\u0026#34;: \u0026#34;$current.createdOrg.id\u0026#34;, \u0026#34;fireImmediately\u0026#34;: true } ] } } "},{"id":18,"href":"/docs/03.eca-rules/%E8%A7%84%E5%88%99%E9%AA%8C%E8%AF%81/","title":"规则验证","section":"三. Eca Rules","content":"验证规则及调试 #   在规则保存成功后，就可以到对应的方案中进行规则验证。\n 确认规则被加载 #  1.表单 #   在 bizForm/init 接口中，可以通过 response 是否返回了规则，来验证 规则是否被加载。\n 注意❗，目前表单规则中，会返回三部分内容：\n 2019年底，在 go 上使用 BizFormRuleManager。AddXXXControl 的规则，id前缀为 \u0026quot;Old-{RuleName}\u0026quot;  2020年底，使用第一版规则工具录入的规则，id前缀为 \u0026quot;{RuleName}-\u0026quot;  使用 ECA Rules 录入的全新规则，id 没有前缀  其中，我们通过配置工具录入的规则，是没有任何前缀的。同时，在多组织后，我们会逐步迁移老代码的规则，敬请各位期待 🤪\n调试 #   现阶段，可以通过断点的方式进行调试，目前我们正在推动执行过程数据收集，后续可以根据数据进行问题排查。\n 所以规则的运行时代码，都在这里，根据规则名称就可以找到对应的执行代码。所有规则的运行时代码，都会实现 IBizRuleActions 这个接口\n/** * @link http://gitlab.q7link.com/front/platform/common-solution/-/blob/feature-multi-org2/src/eca/actions/declare.ts */ export interface IBizRuleActions\u0026lt;T = any\u0026gt; { readonly name: string; schema: JSONSchema7; schemaDefs?: Record\u0026lt;string, JSONSchema7\u0026gt; getExpression?(param: T): RuleFieldItem[] execute(ctx: IRuleActionContext, params: T); } 快捷查看eca #  bizFormPresenter.api.ecaRules.collections.reduce((arr,item)=\u0026gt;[...arr, ...item.items],[]).reduce((arr,i)=\u0026gt;[...arr, ...i.actions.reduce((a,ii)=\u0026gt;[...a, ...[{...ii, id: i.id, reference: i.reference}]], [])], [])\n如果想过滤一下, 比如 product 的赋值\nbizFormPresenter.api.ecaRules.collections.reduce((arr,item)=\u0026gt;[...arr, ...item.items],[]).reduce((arr,i)=\u0026gt;[...arr, ...i.actions.reduce((a,ii)=\u0026gt;[...a, ...[{...ii, id: i.id, reference: i.reference}]], [])], []).filter(i=\u0026gt;i.name.includes('Assignment')).filter(i=\u0026gt;i.params.field=='product')\n其他过滤可以自己应用, 我将其中的 id 和 reference 带到了 actions 上, 便于直接查看.\n"},{"id":19,"href":"/docs/03.eca-rules/reactivefieldvalidator/","title":"ReactiveFieldValidator","section":"三. Eca Rules","content":"ReactiveFieldValidator #   创建一个响应式的字段状态，会根据条件实时添加或删除对应 Validator\n type IReactiveFieldValidatorItem = struct { /** Validator 名称 */ Name string `json:\u0026#34;name\u0026#34;` /** 验证参数 */ Params map[string]interface{} `json:\u0026#34;params\u0026#34;` /** 是否是结构化的 默认是false 如果是false 则 按照实例进行验证 也就是验证加载FormField 实例 如果结构化为true 会剔除实例的影响 直接用logicPath 新增验证 这样的话 就会对当前字表的某一列都有效 */ IsStruct bool `json:\u0026#34;isStruct\u0026#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:\u0026#34;when,omitempty\u0026#34;` /** 是否立即执行 默认值：false */ FireImmediately bool `json:\u0026#34;fireImmediately\u0026#34;` } type IReactiveFieldValidatorParams = struct { /** 目标字段 */ Field string `json:\u0026#34;field\u0026#34;` /** 校验器定义 */ Effect *IReactiveFieldValidatorItem `json:\u0026#34;effect,omitempty\u0026#34;` Effects []*IReactiveFieldValidatorItem `json:\u0026#34;effects,omitempty\u0026#34;` } "},{"id":20,"href":"/docs/03.eca-rules/reactivefieldcomponentprops/","title":"ReactiveFieldComponentProps","section":"三. Eca Rules","content":"ReactiveFieldComponentProps #   创建一个响应式的透传UI组件Props动作，会自动根据依赖数据实时计算新的 props 结果，并添加到目标字段对应的 UI 组件上\n type IReactiveFieldComponentPropsItem = struct { Props map[string]interface{} `json:\u0026#34;props,omitempty\u0026#34;` IsDestruct bool `json:\u0026#34;isDestruct\u0026#34;` When string `json:\u0026#34;when,omitempty\u0026#34;` FireImmediately bool `json:\u0026#34;fireImmediately,omitempty\u0026#34;` } type IReactiveFieldComponentProps = struct { Field string `json:\u0026#34;field\u0026#34;` Effect *IReactiveFieldComponentPropsItem `json:\u0026#34;effect,omitempty\u0026#34;` Effects []*IReactiveFieldComponentPropsItem `json:\u0026#34;effects,omitempty\u0026#34;` } 示例 #  { \u0026#34;name\u0026#34;: \u0026#34;ReactiveFieldComponentProps\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;createdOrg\u0026#34;, \u0026#34;effect\u0026#34;: { \u0026#34;props\u0026#34;: { \u0026#34;orgRoleTypeIds\u0026#34;: [ \u0026#34;InventoryOrg\u0026#34; ] }, \u0026#34;isDestruct\u0026#34;: false, \u0026#34;when\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;fireImmediately\u0026#34;: true } } } "},{"id":21,"href":"/docs/03.eca-rules/assignment/","title":"Assignment","section":"三. Eca Rules","content":"Assignment #   给目标字段进行赋值\n type IAssignmentParams struct { /** * 被赋值字段 */ Field string `json:\u0026#34;field\u0026#34;` /** * 赋值结果，支持表达式 */ Expr string `json:\u0026#34;expr\u0026#34;` } 示例 #  1. 仓库子表初始化默认值 #  { \u0026#34;id\u0026#34;: \u0026#34;d4f0a045-f3c2-4b59-be9d-279edfe08184\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;表体初始化默认值\u0026#34;, \u0026#34;reference\u0026#34;: \u0026#34;miscReceiptItems\u0026#34;, \u0026#34;condition\u0026#34;: { \u0026#34;if\u0026#34;: \u0026#34;$current.editFlag === \u0026#39;add\u0026#39; \u0026amp;\u0026amp; $current.srcObject === undefined\u0026#34; }, \u0026#34;actions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Assignment\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;expr\u0026#34;: \u0026#34;$root.warehouse\u0026#34;, \u0026#34;field\u0026#34;: \u0026#34;warehouse\u0026#34; } } ] } "},{"id":22,"href":"/docs/03.eca-rules/fieldvalidatorrelations/","title":"FieldValidatorRelations","section":"三. Eca Rules","content":"FieldValidatorRelations #   校验规则的字段间关系描述\n type IFieldValidatorRelationsItem = struct { /** * 目标字段 */ Source string `json:\u0026#34;source\u0026#34;` /** * 校验字段 */ Targets []string `json:\u0026#34;targets\u0026#34;` /** * 是否双向影响 * 默认值：false */ Bidirectional bool `json:\u0026#34;bidirectional\u0026#34;` } type IFieldValidatorRelations = struct { Relations []IFieldValidatorRelationsItem `json:\u0026#34;relations\u0026#34;` } 示例 #  1. #  { \u0026#34;name\u0026#34;: \u0026#34;FieldValidatorRelations\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;relations\u0026#34;: [ { \u0026#34;bidirectional\u0026#34;: true, \u0026#34;source\u0026#34;: \u0026#34;businessDate\u0026#34;, \u0026#34;targets\u0026#34;: [ \u0026#34;startUsedDate\u0026#34; ] } ] } } "},{"id":23,"href":"/docs/03.eca-rules/reactiveassignment/","title":"ReactiveAssignment","section":"三. Eca Rules","content":"ReactiveAssignment #   创建一个响应式的赋值动作，会根据规则中的依赖字段返回实时的新计算结果，并赋给目标字段\n type IReactiveAssignmentEffect = struct { /** 取值表达式 */ Expr string `json:\u0026#34;expr\u0026#34;` /** 当目标字段有值时，根据 overrideExpr 的结果来判断是否需要覆盖 默认值：false */ Override bool `json:\u0026#34;override\u0026#34;` /** 当取值表达式为空时，根据 autoClear 的结果判断是否同步清空 默认值：false */ AutoClear bool `json:\u0026#34;autoClear\u0026#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:\u0026#34;when,omitempty\u0026#34;` /** 是否立即生效 默认值：false */ FireImmediately bool `json:\u0026#34;fireImmediately\u0026#34;` } type IReactiveAssignmentEffectV2 = struct { /** 取值表达式 */ Expr string `json:\u0026#34;expr\u0026#34;` /** 当目标字段有值时，根据 overrideExpr 的结果来判断是否需要覆盖 默认值：false */ Override string `json:\u0026#34;override\u0026#34;` /** 当取值表达式为空时，根据 autoClear 的结果判断是否同步清空 默认值：false */ AutoClear string `json:\u0026#34;autoClear\u0026#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:\u0026#34;when,omitempty\u0026#34;` /** 是否立即生效 默认值：false */ FireImmediately string `json:\u0026#34;fireImmediately\u0026#34;` } type IReactiveAssignmentParams = struct { /** 目标字段 */ Field string `json:\u0026#34;field\u0026#34;` /** 赋值来源 */ Effect *IReactiveAssignmentEffect `json:\u0026#34;effect,omitempty\u0026#34;` Effects []*IReactiveAssignmentEffect `json:\u0026#34;effects,omitempty\u0026#34;` } type IReactiveAssignmentParamsV2 = struct { /** 目标字段 */ Field string `json:\u0026#34;field\u0026#34;` /** 赋值来源 */ Effect *IReactiveAssignmentEffectV2 `json:\u0026#34;effect,omitempty\u0026#34;` Effects []*IReactiveAssignmentEffectV2 `json:\u0026#34;effects,omitempty\u0026#34;` } 示例 #  1.明细行主单位根据存货带出 #  { \u0026#34;name\u0026#34;: \u0026#34;ReactiveAssignment\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;主单位跟具存货赋值\u0026#34;, \u0026#34;params\u0026#34;:{ \u0026#34;effects\u0026#34;:[ { \u0026#34;autoClear\u0026#34;:true, // \u0026#34;expr\u0026#34;:\u0026#34;$current.product.unit\u0026#34;, // 赋值表达式：取存货下的unit \u0026#34;fireImmediately\u0026#34;:true, // 是否立即执行 \u0026#34;when\u0026#34;:\u0026#34;true\u0026#34; // 只有为 true 时才执行 } ], \u0026#34;field\u0026#34;:\u0026#34;baseUnit\u0026#34; // 需要被赋值（操作）的字段名： 主单位 } } "},{"id":24,"href":"/docs/03.eca-rules/%E5%A4%B4%E4%BD%93%E5%AD%97%E6%AE%B5%E5%80%BC%E5%90%8C%E6%AD%A5/","title":"头体字段值同步","section":"三. Eca Rules","content":"ReactiveMasterToTables #   创建一个响应式的表头同步数据到表体，会根据表头的表达式结果，实时进行同步\n /** * 子表设置 */ type IReactiveMasterToTablesTarget = struct { /** * 子表字段名 */ DataTable string `json:\u0026#34;dataTable\u0026#34;` /** * 同步的列字段名 */ Field string `json:\u0026#34;field\u0026#34;` /** * 数据过滤表达式，类似之前的视图，只有在满足表达式条件下的数据行，会被同步数据 * expr =\u0026gt; boolean, defaultWhen =\u0026gt; ignore disabled | readonly */ ViewName string `json:\u0026#34;viewName,omitempty\u0026#34;` /** * 数据过滤表达式，类似之前的视图，只有在满足表达式条件下的数据行，会被同步数据 * expr =\u0026gt; boolean, defaultWhen =\u0026gt; ignore disabled | readonly */ When string `json:\u0026#34;when,omitempty\u0026#34;` /** * force update all */ Always string `json:\u0026#34;always,omitempty\u0026#34;` } /** * 表头字段同步到子表上 */ type IReactiveMasterToTablesParams = struct { /** * 表头字段表达式 */ SourceValue string `json:\u0026#34;sourceValue\u0026#34;` /** * 子表设置 */ Target *IReactiveMasterToTablesTarget `json:\u0026#34;target,omitempty\u0026#34;` /** * 多子表设置（推荐） */ Targets []*IReactiveMasterToTablesTarget `json:\u0026#34;targets,omitempty\u0026#34;` } 字段值\nReactiveTablesToMaster #   创建一个响应式的表体同步数据到表头，会根据表体的表达式计算结果，实时进行同步\n  viewName： ContractView（合同）， ManualAdd（手动新增）\n /** * 子表设置 */ type IReactiveTablesToMasterSourceValue = struct { /** * 子表字段名 */ DataTable string `json:\u0026#34;dataTable\u0026#34;` /** * 子表中取值的表达式，可以是简单的字段值，也可以是复杂的计算结果 */ Expr string `json:\u0026#34;expr\u0026#34;` /** * 数据过滤表达式，类似之前的视图，只有在满足表达式条件下的数据行，会作为数据源 */ When string `json:\u0026#34;when,omitempty\u0026#34;` /** * 视图名称，如果同时存在 viewName 和 when，则同时生效 */ ViewName string `json:\u0026#34;viewName,omitempty\u0026#34;` /** * 当满足这个表达式时，同步全部数据，和 when 有点儿类似 */ Always string `json:\u0026#34;always,omitempty\u0026#34;` } /** * params 中，以下几个参数暂时兼容老的写法，后期需要重构及优化： * - disableFieldWhenDifferent * - onlyHandleDisabled * - clearFieldWhenDifferent * */ type IReactiveTablesToMasterParams = struct { /** * 主表字段名 */ Field string `json:\u0026#34;field\u0026#34;` /** * 当子表数据不同时，设置主表字段不可编辑 * 默认值 = true */ DisableFieldWhenDifferent bool `json:\u0026#34;disableFieldWhenDifferent,omitempty\u0026#34;` /** * 只控制表头字段状态，不进行值的会写同步 * 默认值 = false */ OnlyHandleDisabled bool `json:\u0026#34;onlyHandleDisabled,omitempty\u0026#34;` /** * 当子表数据不同时，清空主表字段 * 默认值 = true */ ClearFieldWhenDifferent bool `json:\u0026#34;clearFieldWhenDifferent,omitempty\u0026#34;` /** * 多个子表数据聚合计算的方法 * 默认值 = \u0026#39;Equal\u0026#39; */ AggregationMethod string `json:\u0026#34;aggregationMethod,omitempty\u0026#34;` /** * 计算精度的获取方式 */ PrecisionExpr string `json:\u0026#34;precisionExpr,omitempty\u0026#34;` /** * 是否立即执行 */ FireImmediately bool `json:\u0026#34;fireImmediately,omitempty\u0026#34;` /** * 子表设置 */ SourceValue *IReactiveTablesToMasterSourceValue `json:\u0026#34;sourceValue,omitempty\u0026#34;` /** * 子表设置（推荐） */ SourceValues []*IReactiveTablesToMasterSourceValue `json:\u0026#34;sourceValues,omitempty\u0026#34;` } 示例 #  1. 表头同步到表体 #  { \u0026#34;name\u0026#34;:\u0026#34;ReactiveMasterToTables\u0026#34;, \u0026#34;description\u0026#34;:\u0026#34;表头仓库字段同步到表体仓库字段\u0026#34;, \u0026#34;params\u0026#34;:{ \u0026#34;sourceValue\u0026#34;:\u0026#34;$current.warehouse\u0026#34;, \u0026#34;targets\u0026#34;:[ { \u0026#34;dataTable\u0026#34;:\u0026#34;miscReceiptItems\u0026#34;, \u0026#34;field\u0026#34;:\u0026#34;warehouse\u0026#34;, \u0026#34;viewName\u0026#34;:\u0026#34;ManualAdd\u0026#34;, }, ], \u0026#34;when\u0026#34;:\u0026#34;$root.warehouse.$focused \u0026amp;\u0026amp; $root.warehouse\u0026#34;, } } 2. 表体同步到表头 #  { \u0026#34;name\u0026#34;:\u0026#34;ReactiveTablesToMaster\u0026#34;, \u0026#34;description\u0026#34;:\u0026#34;子表仓库字段不一致时清空表头仓库且设为禁用\u0026#34;, \u0026#34;params\u0026#34;:{ \u0026#34;aggregationMethod\u0026#34;:\u0026#34;Equal\u0026#34;, \u0026#34;clearFieldWhenDifferent\u0026#34;:true, \u0026#34;disableFieldWhenDifferent\u0026#34;:true, \u0026#34;field\u0026#34;:\u0026#34;warehouse\u0026#34;, \u0026#34;fireImmediately\u0026#34;:\u0026#34;true\u0026#34;, \u0026#34;sourceValues\u0026#34;:[ { \u0026#34;dataTable\u0026#34;:\u0026#34;miscReceiptItems\u0026#34;, \u0026#34;expr\u0026#34;:\u0026#34;$current.warehouse\u0026#34;, \u0026#34;viewName\u0026#34;:\u0026#34;Initialized\u0026#34;, \u0026#34;when\u0026#34;:\u0026#34;true\u0026#34;, } ] } } "},{"id":25,"href":"/docs/03.eca-rules/reactivecriteria/","title":"ReactiveCriteria","section":"三. Eca Rules","content":"ReactiveCriteria #   创建一个响应式的过滤条件，会根据规则中的依赖字段返回实时的新过滤条件，并添加到目标字段上\n type IReactiveCriteriaFragment = struct { /** 取值表达式 */ CriteriaStr string `json:\u0026#34;criteriaStr\u0026#34;` /** 动态参数 */ BindVars map[string]interface{} `json:\u0026#34;bindVars,omitempty\u0026#34;` /** 当取值表达式为空时，根据 autoClear 的结果判断是否同步清空 默认值：false */ AutoClear bool `json:\u0026#34;autoClear,omitempty\u0026#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:\u0026#34;when,omitempty\u0026#34;` /** 和其他条件的 与或关系 */ Join string `json:\u0026#34;join,omitempty\u0026#34;` /** 是否立即生效 默认值：false */ FireImmediately bool `json:\u0026#34;fireImmediately,omitempty\u0026#34;` } type IReactiveCriteriaParams = struct { /** 目标字段 */ Field string `json:\u0026#34;field\u0026#34;` /** 过滤因素, 支持简单的静态过滤条件字符串 和 复杂的结构化设置 */ Fragment *IReactiveCriteriaFragment `json:\u0026#34;fragment,omitempty\u0026#34;` Fragments []*IReactiveCriteriaFragment `json:\u0026#34;fragments,omitempty\u0026#34;` } 示例 #  { \u0026quot;name\u0026quot;: \u0026quot;ReactiveCriteria\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;描述\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;field\u0026quot;: \u0026quot;字段id\u0026quot;, \u0026quot;fragment\u0026quot;: { \u0026quot;bindVars\u0026quot;: { \u0026quot;createOrgId\u0026quot;: \u0026quot;$root.createOrg.id\u0026quot; // 变量 }, \u0026quot;criteriaStr\u0026quot;: \u0026quot;createOrgId = :createOrgId\u0026quot;, \u0026quot;fireImmediately\u0026quot;: true, \u0026quot;when\u0026quot;: \u0026quot;$root.createOrg.id !== undefined\u0026quot; } } } "},{"id":26,"href":"/docs/03.eca-rules/reactivefieldstatus/","title":"ReactiveFieldStatusgit","section":"三. Eca Rules","content":"ReactiveFieldStatus #   创建一个响应式的字段状态，会根据依赖数据实时返回新状态，并添加到目标字段上\n type IReactiveFieldStatusEffect = struct { /** 状态名称 目前支持：Readonly、Required */ Status string `json:\u0026#34;status\u0026#34;` /** 状态值表达式 */ Expr interface{} `json:\u0026#34;expr\u0026#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:\u0026#34;when,omitempty\u0026#34;` /** 是否立即生效 默认值：false */ FireImmediately bool `json:\u0026#34;fireImmediately\u0026#34;` } type IReactiveFieldStatusParams = struct { /** 目标字段 */ Field string `json:\u0026#34;field\u0026#34;` /** 状态设置 */ Effect *IReactiveFieldStatusEffect `json:\u0026#34;effect,omitempty\u0026#34;` Effects []*IReactiveFieldStatusEffect `json:\u0026#34;effects,omitempty\u0026#34;` } 示例 #  1. 当创建组织为空时，startPeriod 字段禁用 #  { \u0026quot;name\u0026quot;: \u0026quot;ReactiveFieldStatus\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;描述处理的场景\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;effect\u0026quot;: { \u0026quot;expr\u0026quot;: \u0026quot;true\u0026quot;, // \u0026quot;fireImmediately\u0026quot;: true, // 是否立即执行 \u0026quot;status\u0026quot;: \u0026quot;Readonly\u0026quot;, // Readonly，Required \u0026quot;when\u0026quot;: \u0026quot;$root.createdOrg === undefined\u0026quot; // 触发条件 }, \u0026quot;field\u0026quot;: \u0026quot;startPeriod\u0026quot; // 处理字段 } }, 根据外件控制敏感字段 #  { \u0026#34;name\u0026#34;: \u0026#34;ReactiveFieldStatus\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;effect\u0026#34;: { \u0026#34;expr\u0026#34;: \u0026#34;!$fn.isCarryFieldVisible(\u0026#39;spec\u0026#39;, $current.product)\u0026#34;, \u0026#34;fireImmediately\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;Sensitive\u0026#34; }, \u0026#34;field\u0026#34;: \u0026#34;product.spec\u0026#34; } } "},{"id":27,"href":"/docs/05.form-guide/%E8%A7%86%E5%9B%BE/","title":"视图","section":"五. BizForm实用攻略","content":"适用于表单。\n 主表presenter的getDataOptions  dynamicViews: { [F_BudgetAccount_refDocMappings(子表名字)]: \u0026#39;viewName(视图名字)\u0026#39;, }, 子表presenter  // 视图的数据 private viewData = observable.array([]); // 查看态 onFormViewed(form: EntityForm\u0026lt;any\u0026gt;, disposers: IDisposer[]) { this.addView(disposers) } // 编辑态 onFormCreated(form: EntityForm\u0026lt;any\u0026gt;, disposers: IDisposer[]) { this.addView(disposers) } addView = (disposers) =\u0026gt; { this.formPresenter.formController.addDynamicView( this.logicPath, \u0026#39;viewName\u0026#39;, this.viewData, ) disposers.push( // 监听子表的数据变化  reaction( () =\u0026gt; { return this.form.select(this.logicPath).value.slice(); }, this.updateData, { fireImmediately: true }, ), ); } // 将子表数据进行处理后赋值给视图数据 updateData = () =\u0026gt; { const data = this.form.select(this.logicPath).value this.viewData.replace(data.filter()); } "},{"id":28,"href":"/docs/10.multi-org/%E5%9D%91/","title":"坑","section":"十. 多组织","content":"列表的路由不能传path参数 #  文档里说要用renderDocumentListRouters这个方法生成路由，但是不能传path参数指定url。 它的内部用renderDocumentList和renderMultiOrgDocumentList2个方法生成了一个普通列表路由，一个多组织列表的路由。\n为了解决传path的问题，可以像下面这样写代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  { ...renderDocumentList({ title: \u0026#39;编制方案设置\u0026#39;, entityName: EN_BudgetModel, groupName: `${EN_BudgetModel}_list`, createPresenter: async options =\u0026gt; { const { BudgetModelList } = await import( \u0026#39;@main/screens/projects/budget/budget-model/list/BudgetModelList\u0026#39; ); return new BudgetModelList({ ...options }); }, }), refreshWhenParamsChanged: true, path: appRouterHashManager.generateHashDef(EN_BudgetModel, PageModeEnum.List),  }, { ...renderMultiOrgDocumentList({ entityName: EN_BudgetModel, groupName: defaultMultiOrgGroupName(EN_BudgetModel), title: `编制方案设置多组织查询`, createPresenter: async options =\u0026gt; { const { BudgetModelList } = await import( \u0026#39;@main/screens/projects/budget/budget-model/list/BudgetModelList\u0026#39; ); return new BudgetModelList({ ...options }); }, }) },   这里就是用renderDocumentList和renderMultiOrgDocumentList分别创建两个路由。\n多组织查询按钮不显示 #  如果列表presenter中有commandActionResolver方法，则需要调一下super方法，否则的话就不会显示出多组织查询按钮。\nconst actions = super.commandActionResolver(commandActions) "},{"id":29,"href":"/docs/05.form-guide/%E5%A4%96%E9%94%AE%E7%A9%BF%E9%80%8F%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/","title":"外键穿透的自定义点击事件","section":"五. BizForm实用攻略","content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  protected onInitialized(formPresenter) { formPresenter.getBean(BeanNames.EventController).on(InternalEvent.onCancel, this.cancel); const isTemplateBill = this.isTemplateBill; if (isTemplateBill) { // 修改外键（项目project）的onClick的穿透的行为。当是计划模板时，穿透到项目模板。  const masterRenderController = this.formPresenter.getBean(BeanNames.MasterRendererController); const billTypeId = this.getBillTypeId(); const options: ForeignKeyLinkRenderOption = { onClick(params: ForeignKeyLinkClickParams) {  if (params.entityName === EN_Project){ const hash = appRouterHashManager.generateHash(\u0026#39;ProjectTemplate\u0026#39;, PageModeEnum.Form as any, { mode: BizFormModeEnum.View, copyId: params.id, id: params.id, data: {}, billTypeId, }); proxyHistory.push(hash) } }, } masterRenderController.add(NewForeignKeyLinkRender(options)) } }   主要是第10行的onClick，可以重新定义外键穿透的默认的onClick。比如穿透到另一个entityName，或者搞一个弹窗。\n"},{"id":30,"href":"/docs/05.form-guide/%E5%9C%BA%E6%99%AF%E5%80%BCreaction/","title":"场景值reaction","section":"五. BizForm实用攻略","content":"如果表单的A字段设置了reaction监听。当修改A的value的时候，对应的reaction都会触发。如果希望不触发reaction，就要用到下面的场景值reaction\n// 根据场景值忽略执行的reaction const reactionOmit = this.bizFormPresenter.api.reactionOmitCreator( BizFormScenarios.SourcePicking, ); // 使用reactionOmit监听 disposers.push( reactionOmit( () =\u0026gt; form.select(\u0026#39;F_TimesheetLine_orgRoleType\u0026#39;).value, value =\u0026gt; { } ) ) // 使用reactionOmit对应的场景值赋值，就不会触发reaction this.bizFormPresenter.api.runInScenarios(BizFormScenarios.SourcePicking, () =\u0026gt; { rowField.select(F_TimesheetLine_orgRoleType).value = { id: EN_Department, title: \u0026#39;部门\u0026#39;, name: EN_Department, }; }) "},{"id":31,"href":"/docs/05.form-guide/%E8%A1%A8%E5%A4%B4%E5%AD%97%E6%AE%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93/","title":"表头字段自定义渲染","section":"五. BizForm实用攻略","content":"表单中配置masterRender可以实现表头字段的自定义渲染，但是外键字段不能通过masterRender处理。\n在MasterRendererController.tsx中有一段代码\nconst after: IMasterFieldRender[] = [new LinkRender(), new ForeignKeyLinkRender(), new CommonFieldRender()]; 外键字段会走到ForeignKeyLinkRender组件，而masterRender只在CommonFieldRender中才有使用。\nprotected getDisplayOptions(): DisplayOptions { return { masterRender: { [\u0026#39;project\u0026#39;]: props =\u0026gt; { const LinkDiv = styled.div` height: 100%; display: flex; align-items: center; padding-left: 8px; cursor: pointer; color: var(--primary-500); text-decoration: underline; text-underline-position: under; ` return ( \u0026lt;MSTFormElement label={props.template.title} path={\u0026#39;project\u0026#39;} colspan={1} disableError={true} disabled={true} isRequired={false} labelResolver={value =\u0026gt; value[\u0026#39;project\u0026#39;]} // value 对应的 path={...}中的值 contentRenderer={() =\u0026gt; { const data = props.form.value.project return ( \u0026lt;LinkDiv\u0026gt; \u0026lt;span onClick={async () =\u0026gt; { const hash = appRouterHashManager.generateHash(EN_Project, PageModeEnum.Form, { mode: BizFormModeEnum.View, copyId: data.id, id: data.id, data: data, billTypeId: this.formValue.billType.id, queryStringParams: { [F_ProjectSchedule_isTemplateBill]: this.isTemplateBill, }, }); proxyHistory.push(hash) }}\u0026gt;{data.code}\u0026lt;/span\u0026gt; \u0026lt;/LinkDiv\u0026gt; ) }} /\u0026gt; ); }, } } } "},{"id":32,"href":"/docs/06.list-guide/%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90/","title":"按钮权限","section":"六. 列表方案攻略","content":"多列表方案处理了顶部按钮的权限，但是要在列表方案中指定resourceId\npublic getQueryListOption(): IQueryListSolutionPresenterOptions { return { ...super.getQueryListOption(), resourceId: \u0026#39;xxxxxxxxxxxxxxx\u0026#39;, }; } "},{"id":33,"href":"/docs/06.list-guide/queryfield/","title":"QueryField","section":"六. 列表方案攻略","content":"列表数据会查询哪些字段一般是在预置数据里设置的。也可以通过代码控制。\n1 2 3 4 5 6 7 8 9 10 11 12 13  export class ProjectConfirmationListListPresenter extends QueryListPagePresenter { getQueryListOption(): IQueryListSolutionPresenterOptions { return { ...super.getQueryListOption(), resourceId: ResourceConstants.Res_ProjectConfirmation, getDynamicQueryFields: () =\u0026gt; { return [\u0026#39;task.project.id\u0026#39;]; }  }; } }   "},{"id":34,"href":"/docs/06.list-guide/%E8%A1%8C%E6%8C%89%E9%92%AErowaction/","title":"行按钮rowAction","section":"六. 列表方案攻略","content":"适用于：多列表\n效果图： export class BudgetModelList extends QueryListPagePresenter { // 覆盖父类的方法  getRowActions(rowIndex: number, data: any): IGridAction[] { // 获取公共默认的actions  const actions = this.presenter.listSolutionConnector.rowActionController.makeDefaultRowActions( data, ); if (data \u0026amp;\u0026amp; data.id) { // 加新的按钮  actions.push({ icon: ICON_VIEW, title: \u0026#39;预览\u0026#39;, key: \u0026#39;preview\u0026#39;, onClick: (rowIndex, data) =\u0026gt; this.preview(data), }); } // 还可以对actions数组进行过滤  return actions; } } "},{"id":35,"href":"/docs/05.form-guide/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E6%8D%AE/","title":"自定义单据","section":"五. BizForm实用攻略","content":"两部分组成：\n 创建form form组件  function createForm(): EntityForm { const formScheme = { closeDate: { type: FieldTypeEnum.Timestamp, initState: { label: \u0026#39;关闭日期\u0026#39;, required: false, visible: false, }, }, closedReason: { type: FieldTypeEnum.JsonObject, referType: EN_BizReason, initState: { label: \u0026#39;关闭原因\u0026#39;, required: false, visible: false, }, }, closedReasonExplain: { type: FieldTypeEnum.String, initState: { label: \u0026#39;关闭原因说明\u0026#39;, required: false, visible: false, }, }, }; const formBuilder = new FormBuilder(); Object.entries(formScheme).forEach(([key, value]) =\u0026gt; { formBuilder.appendField(key, makeField(value)); }); return formBuilder.toForm({}); } function CloseInfoForm({ form }: { form: EntityForm }) { return ( \u0026lt;MSTFormLayout form={form} columnSize={1}\u0026gt; \u0026lt;MSTFormElement path={\u0026#39;closeDate\u0026#39;} /\u0026gt; \u0026lt;MSTFormElement path=\u0026#34;closedReason\u0026#34;\u0026gt; \u0026lt;Observer\u0026gt; {() =\u0026gt; ( \u0026lt;Refer entityName={EN_BizReason} value={form.value[\u0026#39;closedReason\u0026#39;]} isMulti={false} onChange={value =\u0026gt; { form.select(\u0026#39;closedReason\u0026#39;).value = value; }} /\u0026gt; )} \u0026lt;/Observer\u0026gt; \u0026lt;/MSTFormElement\u0026gt; \u0026lt;MSTFormElement path=\u0026#34;closedReasonExplain\u0026#34; /\u0026gt; \u0026lt;/MSTFormLayout\u0026gt; ); } "},{"id":36,"href":"/docs/06.list-guide/%E9%80%89%E4%B8%AD%E8%A1%8C/","title":"选中行","section":"六. 列表方案攻略","content":"适用于：多列表方案\nthis.presenter.listSolutionConnector.selectionItems "},{"id":37,"href":"/docs/06.list-guide/%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE/","title":"顶部按钮ToolbarAction","section":"六. 列表方案攻略","content":"适用于：多列表方案\n效果图： export class ProjectListPagePresenter extends QueryListPagePresenter{ protected commandActionResolver(commandActions: ToolbarAction[]): ToolbarAction[] { // 简单的action  commandActions.unshift({ id: \u0026#39;project-view\u0026#39;, group: ToolbarActionGroup.Group1, action: this.presenter.toolbarConnector.makeCreateButton({ onClick: billTypeId =\u0026gt; { }, }), }); // 复杂的action  commandActions.push(new ProjectMultiCloseAction(this.presenter.listSolutionConnector)) } }  覆盖父类的commandActionResolver方法。向参数commandActions数组中添加ToolbarAction元素即可。 ToolbarAction有两种方式创建。 简单的话，可以用对象字面量创建。 复杂的话，就用一个对象来实现ToolbarAction。参考ProjectMultiCloseAction  "},{"id":38,"href":"/docs/05.form-guide/%E7%BC%96%E8%BE%91%E6%88%96%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6/","title":"编辑或显示数字精度","section":"五. BizForm实用攻略","content":"控制编辑，设置editParams\npublic getEditOptions(): EditOptions { return { editParams: { [主表字段名]: () =\u0026gt; { return { numericProps: { decimalPlaces: 精度, minimumValue: \u0026#39;0\u0026#39;, } } }, [`子表名.子表字段名`]: () =\u0026gt; { return { numericProps: { decimalPlaces: 精度, minimumValue: \u0026#39;0\u0026#39;, } } }, } } } 控制显示，子表要自定义渲染\ngetGridOptions(): Optional\u0026lt;AdvanceGridProps\u0026gt; { return { columnResolver: (colDefs: ColDef[]) =\u0026gt; { const daysField = colDefs.find(c =\u0026gt; c.field === F_TimesheetLine_days); if (daysField) { daysField.cellRendererFramework = (params) =\u0026gt; { return React.createElement(\u0026#39;p\u0026#39;, null, params.data[F_TimesheetLine_days]) } } }, }; } "},{"id":39,"href":"/docs/05.form-guide/%E6%B0%B4%E5%8D%B0/","title":"水印","section":"五. BizForm实用攻略","content":"go项目\n trek/services/form-services/middlewares/entities/【实体名】/params.go  // 1. 实体的哪些字段要作为水印 var watermarkFieldNames = []string{ gen_ef.F_Project_billFullStatusObject, gen_ef.F_Project_budgetStatus, } var ( // 2. \twatermarkSettingParams = form_service_middlewares_common.WatermarkSettingMiddlewareCreatorParams{ Items: form_service_middlewares_common.DefaultWatermarkSettingItemsCreator(watermarkFieldNames...), } // 3. \tbillCommonRulesParams = form_service_middlewares_common.BillCommonRulesCreatorParams{ WatermarkSettingMiddlewareCreatorParams: \u0026amp;watermarkSettingParams, } ) trek/services/form-services/middlewares/entities/【实体名】/index.go  func GetMiddlewareCreators() []form_context.FormMiddlewareCreator { middlewareCreators := []form_context.FormMiddlewareCreator{ // 1. \tform_service_middlewares_common.BillCommonRulesMiddlewareCreator(billCommonRulesParams), } } "},{"id":40,"href":"/docs/02.form/%E5%AD%90%E8%A1%A8/","title":"子表","section":"二. BizForm基础","content":"formPresenter一般都是在路由中初始化的。 业务presenter（都是继承了 EasyBizFormPresenter）的构造器中会调用super， super中会调createItemsPresenters将子表也new出来，让子表保存到 itemsPresenters 中。 可以在业务presenter中遍历 itemsPresenters 通过 itemsPresenter 的 logicPath （子表的path）拿到某个子表对象。\n"},{"id":41,"href":"/docs/07.component/%E6%8F%90%E7%A4%BA/","title":"提示","section":"七. 组件","content":"import { showError, showInfo, showSuccess } from \u0026#39;@root/common/toaster\u0026#39;; showSuccess(\u0026#39;text\u0026#39;) 自适应内容高度的提示\n// apps/link/src/main/screens/projects/budget/budget-account/presenter/budget-account-form-presenter/helper.tsx  AlphaWarning( \u0026#39;text\u0026#39;, () =\u0026gt; {}, () =\u0026gt; {}, ); "},{"id":42,"href":"/docs/05.form-guide/value/","title":"Value","section":"五. BizForm实用攻略","content":"Presenter.api.formController.form.select('modelSubtables/0/dimensions/2').value\nPresenter.api.formController.form.getSubmitValue()\n"},{"id":43,"href":"/docs/09.common/%E5%B8%81%E7%A7%8D%E7%B2%BE%E5%BA%A6/","title":"币种精度","section":"九. 通用功能攻略","content":"import { store } from \u0026#39;@models\u0026#39;; // 表单中(EasyBizFormPresenter) this.localCurrency.precision // 不在EasyBizFormPresenter中 store.exchangeDefManager.getLocalCurrency().precision "},{"id":44,"href":"/docs/09.common/%E5%85%A8%E8%B2%8C%E7%BB%9F%E8%AE%A1%E5%8A%A0%E6%8C%87%E6%A0%87/","title":"全貌统计加指标","section":"九. 通用功能攻略","content":"https://shimo.im/sheets/16q8MDar7Ktv0mk7/cayv7，所有的指标会在这个文档里说明。其中【指标编码】是下文中提到的 MeasureId 。\n需要现在go上配置好指标，然后在前端中获取指标并进行设置。\ngo #   trek/services/dashboard/config/project-overview.go addProjectStatisticsConfig函数 addConfig  // 多值指标 addConfig(\u0026amp;dashboard.EvaluateCardConfig{ Id: \u0026#34;projectTimeStatisticCost\u0026#34;, Title: \u0026#34;工时成本\u0026#34;, Icon: \u0026#34;icongongshi1\u0026#34;, ViewType: dashboard.CardViewType_MultiValue, ValueConfig: []dashboard.EvaluateValueConfig{ { Id: \u0026#34;workingTimeCost\u0026#34;, Icon: \u0026#34;iconzonggongshi\u0026#34;, Title: \u0026#34;总工时成本\u0026#34;, MeasureId: \u0026#34;workingTimeCost\u0026#34;, Unit: dashboard.CardViewUnit_TenThounsand, ClassName: \u0026#34;color1\u0026#34;, SupportPenetrate: true, IsAmount: true, ValuePeriodType: dashboard.MeasurePeriodValueTypeOccurs, }, } }) // 单值指标 addConfig(\u0026amp;dashboard.EvaluateCardConfig{ Id: \u0026#34;workingTimeCost\u0026#34;, Title: \u0026#34;总工时成本\u0026#34;, Icon: \u0026#34;\u0026#34;, ViewType: dashboard.CardViewType_SingleValue, ValueConfig: dashboard.EvaluateValueConfig{ Id: \u0026#34;count\u0026#34;, Icon: \u0026#34;iconzonggongshi\u0026#34;, Title: \u0026#34;总工时成本\u0026#34;, MeasureId: \u0026#34;workingTimeCost\u0026#34;, Unit: dashboard.CardViewUnit_TenThounsand, IsAmount: true, ClassName: \u0026#34;color1\u0026#34;, SupportPenetrate: true, ValuePeriodType: dashboard.MeasurePeriodValueTypeOccurs, }, }) 需要格外注意的几个字段的说明：\n ViewType：单值指标还是多值指标 IsAmount：金额，会受到单位设置（元或万元）影响 Unit：单位，设置为万元，会收到单位设置影响 MeasureId：文章开头提到的指标编码 Id：前端匹配用的id，与 MeasureId 保持一致  前端 #   进入目录apps/link/src/main/screens/projects/project-view/Statistics，将用到 default/constant.ts,default/defaultLayout.ts,Statistics.ts等几个文件。 在 constant.ts 文件中，将go上定义的各个指标的 Id 都定义到 moduleKeys 中。 defaultLayout.ts文件，在defaultMainLayoutWithContract和defaultMainLayout两个数组中分别加指标，并修改contractConfigVersion和configVersion两个版本号。  getSingleDimension({ i: moduleKeys.WorkingTimeCost, x: 2, y: 5, defaultShow: false, }), getMulDimension({ i: moduleKeys.ProjectTimeStatisticCost, x: 0, y: 1, defaultShow: false, }), Statistics.tsx文件，cardList变量，在其中加入各个指标的 Id  "},{"id":45,"href":"/docs/09.common/%E6%A8%A1%E5%9D%97%E5%90%AF%E7%94%A8/","title":"模块启用","section":"九. 通用功能攻略","content":"go #  go项目，获取功能权限是否开启\nb := ctx.GetBusinessModuleById(gen_ec.EC_BusinessModule_BusinessModule_budget) // b.IsEnabled 前端 #  import { store } from \u0026#39;@models\u0026#39;; class A { b() { const contractModel = store.moduleInitManager.getModuleById(\u0026#39;BusinessModule_contract\u0026#39;); if ( !contractModel || !contractModel.isEnabled ) { // ...  } } } "},{"id":46,"href":"/docs/09.common/gen/","title":"Gen","section":"九. 通用功能攻略","content":" 后端实体构建发版后，前端和go 要生成相应的 json\n 1. go 端 #  进入 script 目录运行\n sh gen.sh 2. 前端 #  直接运行 rush gen 环境\n问题 #    某些变量在本地跑完gen后不见了\n 可能是后端该了某些属性的名字，但是0租户没有同步。    go 执行gen 后，运行经常报错：某些常量找不到\n 可以通过 go-gen/extend/extends.go 进行扩展 具体代码参考他人的写法\n   "},{"id":47,"href":"/docs/05.form-guide/allpaths/","title":"AllPaths","section":"五. BizForm实用攻略","content":"bizFormPresenter.api.formController.entityCRUD.allPaths bizFormPresenter.api.getForm().select('timesheetLines/0/indvRole') "},{"id":48,"href":"/docs/06.list-guide/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/%E6%9F%A5%E8%AF%A2%E9%A1%B9%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/","title":"查询项的默认值","section":"查询方案","content":"这里介绍如何为查询项设置默认值。 #  方法一在 go 层设置 #  参看：trek/services/query-list/middlewares/entities/project-schedule/query-default-value.go\n主要的代码是这段,不提倡这种方式设置默认值\nfunc (m *billStatusObjectMiddleware) QueryDefHandler(ctx query_list.QueryListContext, api query_list.QueryDefApi) { schema := api.GetQueryItemSchema(billStatusObjectFieldName) if schema != nil { defaultVal := map[string]interface{}{ \u0026#34;values\u0026#34;: []defItem{ { Title: \u0026#34;已生效\u0026#34;, Id: \u0026#34;BillStatus.effective\u0026#34;, }, }, } api.SetDefaultValue(billStatusObjectFieldName, defaultVal) schema.OperatorId = gen_enums.ENUM_CriteriaOperator_in schema.Operator = ctx.GetContext().GetMetadata().GetEnumValue(gen_enums.ENUM_CriteriaOperator, gen_enums.ENUM_CriteriaOperator_in) } } 方法二 直接在列表方案的查询方案中插入默认值 #  常用默认值设置 #  一. 日期相关 #     取 值 表达式     今天 {\u0026quot;length\u0026quot;:1,\u0026quot;offset\u0026quot;:0,\u0026quot;unit\u0026quot;:\u0026quot;day\u0026quot;}   昨天 {\u0026quot;length\u0026quot;:1,\u0026quot;offset\u0026quot;:-1,\u0026quot;unit\u0026quot;:\u0026quot;day\u0026quot;}   本周 {\u0026quot;length\u0026quot;:1,\u0026quot;offset\u0026quot;:0,\u0026quot;unit\u0026quot;:\u0026quot;week\u0026quot;}   上周 {\u0026quot;length\u0026quot;:1,\u0026quot;offset\u0026quot;:-1,\u0026quot;unit\u0026quot;:\u0026quot;week\u0026quot;}   本月 {\u0026quot;length\u0026quot;:1,\u0026quot;offset\u0026quot;:0,\u0026quot;unit\u0026quot;:\u0026quot;month\u0026quot;}   上月 {\u0026quot;length\u0026quot;:1,\u0026quot;offset\u0026quot;:-1,\u0026quot;unit\u0026quot;:\u0026quot;month\u0026quot;}   本季 {\u0026quot;length\u0026quot;:1,\u0026quot;offset\u0026quot;:0,\u0026quot;unit\u0026quot;:\u0026quot;quarter\u0026quot;}   上季 {\u0026quot;length\u0026quot;:1,\u0026quot;offset\u0026quot;:-1,\u0026quot;unit\u0026quot;:\u0026quot;quarter\u0026quot;}   本年 {\u0026quot;length\u0026quot;:1,\u0026quot;offset\u0026quot;:-1,\u0026quot;unit\u0026quot;:\u0026quot;year\u0026quot;}   上年 {\u0026quot;length\u0026quot;:1,\u0026quot;offset\u0026quot;:-1,\u0026quot;unit\u0026quot;:\u0026quot;year\u0026quot;}   最近3天 {\u0026quot;length\u0026quot;:3,\u0026quot;offset\u0026quot;:-2,\u0026quot;unit\u0026quot;:\u0026quot;day\u0026quot;}   最近7天 {\u0026quot;length\u0026quot;:7,\u0026quot;offset\u0026quot;:-6,\u0026quot;unit\u0026quot;:\u0026quot;day\u0026quot;}   最近15天 {\u0026quot;length\u0026quot;:14,\u0026quot;offset\u0026quot;:-14,\u0026quot;unit\u0026quot;:\u0026quot;day\u0026quot;}   最近30天 {\u0026quot;length\u0026quot;:30,\u0026quot;offset\u0026quot;:-29,\u0026quot;unit\u0026quot;:\u0026quot;day\u0026quot;}    "},{"id":49,"href":"/docs/05.form-guide/%E5%8D%95%E6%8D%AE%E7%8A%B6%E6%80%81/","title":"单据状态","section":"五. BizForm实用攻略","content":"export const ENUM_BillStatus = \u0026#34;BillStatus\u0026#34;; // 单据状态 export const ENUM_BillStatus_draft = \u0026#34;BillStatus.draft\u0026#34;; // 未提交 export const ENUM_BillStatus_submitting = \u0026#34;BillStatus.submitting\u0026#34;; // 提交中 export const ENUM_BillStatus_submitted = \u0026#34;BillStatus.submitted\u0026#34;; // 已提交 export const ENUM_BillStatus_approving = \u0026#34;BillStatus.approving\u0026#34;; // 审批中 export const ENUM_BillStatus_effecting = \u0026#34;BillStatus.effecting\u0026#34;; // 生效中 export const ENUM_BillStatus_effective = \u0026#34;BillStatus.effective\u0026#34;; // 已生效 export const ENUM_BillStatus_restarting = \u0026#34;BillStatus.restarting\u0026#34;; // 退回中 export const ENUM_BillStatus_restarted = \u0026#34;BillStatus.restarted\u0026#34;; // 已退回 export const ENUM_BillStatus_recalling = \u0026#34;BillStatus.recalling\u0026#34;; // 撤回中 export const ENUM_BillStatus_recalled = \u0026#34;BillStatus.recalled\u0026#34;; // 已撤回 export const ENUM_BillStatus_closing = \u0026#34;BillStatus.closing\u0026#34;; // 关闭中 export const ENUM_BillStatus_closed = \u0026#34;BillStatus.closed\u0026#34;; // 已关闭 export const ENUM_BillStatus_finishing = \u0026#34;BillStatus.finishing\u0026#34;; // 结案中 export const ENUM_BillStatus_finished = \u0026#34;BillStatus.finished\u0026#34;; // 已结案 export const ENUM_BillStatus_aborting = \u0026#34;BillStatus.aborting\u0026#34;; // 作废中 export const ENUM_BillStatus_aborted = \u0026#34;BillStatus.aborted\u0026#34;; // 已作废 export const ENUM_BillStatus_excepted = \u0026#34;BillStatus.excepted\u0026#34;; // 流程异常 "},{"id":50,"href":"/docs/05.form-guide/%E5%88%A0%E9%99%A4%E8%A1%8C/","title":"删除行","section":"五. BizForm实用攻略","content":"const refDocMappingsField = this.form.select(F_BudgetAccount_refDocMappings); if (refDocMappingsField.value !== undefined) { let len = refDocMappingsField.value.length; while (len\u0026gt;0){ this.formController.deleteRowByRealIndex( F_BudgetAccount_refDocMappings, len - 1, ); len --; } } "},{"id":51,"href":"/docs/06.list-guide/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/%E6%9F%A5%E8%AF%A2%E9%A1%B9/","title":"查询项","section":"查询方案","content":"多列表方案中的 getQueryResolverOptions 方法可以用来设置【查询项】\nclass BudgetPlanBasePresenter extends QueryListPagePresenter { protected getQueryResolverOptions(queryListDef, option): IQueryModelResolverOptions { return { someKey: onModelCreated: (item: QueryItem) =\u0026gt; { item.value } } } } 数据结构\nexport interface IQueryModelResolverOptions { [key: string]: IQueryModelItemResolverOptions | IQueryModelItemResolverCreator; } export type IQueryModelItemResolverCreator = (options) =\u0026gt; IQueryModelItemResolverOptions; export interface IQueryModelItemResolverOptions\u0026lt;T = any\u0026gt; { // 显示查询方案时，每次都会触发  onModelCreated?: (item: QueryItem) =\u0026gt; void; baseFieldOptionsResovler?: ( item: IQueryCriteria, options: FieldOptions, ) =\u0026gt; MSTFormOptions[\u0026#39;fieldOptions\u0026#39;] | FieldOptions; baseTypeResolver?: (item: IQueryCriteria, type: IType\u0026lt;any, any, any\u0026gt;) =\u0026gt; IType\u0026lt;any, any, any\u0026gt;; itemFieldOptionsResolver?: ( item: IQueryCriteria, fieldOptions: MSTFormOptions[\u0026#39;fieldOptions\u0026#39;] | FieldOptions, ) =\u0026gt; MSTFormOptions[\u0026#39;fieldOptions\u0026#39;] | FieldOptions; itemTypeResolver?: (item: IQueryCriteria, modelOptions) =\u0026gt; IType\u0026lt;any, any, any\u0026gt;; parser?: (item: IQueryCriteria\u0026lt;T\u0026gt;) =\u0026gt; any; beforeInitialize?: ( item: IQueryCriteria, gql: GQLQueryCollect, initializers: AsyncInitializer[], queryCriterias: IQueryCriteria[], ) =\u0026gt; Promise\u0026lt;void\u0026gt;; formElementRender?: ( item: QueryItem, commonRender: () =\u0026gt; JSX.Element, filterRender: () =\u0026gt; JSX.Element, ) =\u0026gt; JSX.Element; formElementContentRenderer?: (item: QueryItem) =\u0026gt; JSX.Element; componentRender?: (item: QueryItem) =\u0026gt; JSX.Element; fragmentResolver?: (criteria: ICriteria, item: QueryItem) =\u0026gt; ICriteria; validate?: (field: MSTFormField, item: QueryItem) =\u0026gt; [boolean, string]; // 保存QueryCriteriaValue  toJS?: (value: IQueryCrtieriaValue, item: IQueryCriteria\u0026lt;T\u0026gt;) =\u0026gt; IQueryCrtieriaValue; toHumanString?: (item: QueryItem, operator: string) =\u0026gt; IQueryDescribe; // 值是否为空  isEmptyValue?: (value: IQueryCrtieriaValue, item: QueryItem) =\u0026gt; boolean; } "},{"id":52,"href":"/docs/07.component/advancedialog/","title":"AdvanceDialog","section":"七. 组件","content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import { showDialog, requestDialogId, closeDialog } from \u0026#39;@root/common/dialog\u0026#39;; import { AdvanceDialog } from \u0026#39;@components/advance-dialog/AdvanceDialog\u0026#39;; function renderDialog() { const dialogId = requestDialogId();  showDialog(dialogId, (  \u0026lt;AdvanceDialog isOpen title=\u0026#34;催办\u0026#34; buttons={[{ text: \u0026#39;确定\u0026#39;, onClick: () =\u0026gt; {  closeDialog(dialogId) } }]} onClose={() =\u0026gt; {  closeDialog(dialogId) }} \u0026gt; \u0026lt;/AdvanceDialog\u0026gt; )) }   列宽可以通过鼠标拖动\nenableColResize={true} autoContainerWidth={false} "},{"id":53,"href":"/docs/07.component/refer/","title":"Refer","section":"七. 组件","content":"form中设置 #  getEditOptions之editParams #  editParams是定义每个field（也可以设置子表的field）的编辑态的参数。\n{ [key: fieldName]: 参数对象 } 参数对象需要根据field具体是什么来行确定，比如field可能是数字、字符串、参照等，对应的渲染组件就是NumberField，ReferField，TextField等，参数对象就是对应的渲染组件的参数。\n参数 #  // 高级参照支持多选 enableMultiInsert: true, criteriaStr: criteriaStr, referConfigResolver: referConfig =\u0026gt; { return Object.assign({}, referConfig, { displayField: 'code', }); }, advanceReferProps: { categoryCriteriaStr: , }, queryFields: [], onMultiInsert: ( data: Array\u0026lt;ICustomizedCarryoverProgrammeSubjectSetting\u0026gt;, editRowField: MSTFormField, ) =\u0026gt; { if (Array.isArray(data) \u0026amp;\u0026amp; data.length \u0026gt; 0) { const origin = editRowField.value || []; for (let i = 0, len = data.length; i \u0026lt; len; i += 1) { data[i] = Object.assign(data[i], { summary: origin.summary, }); } } }, enableMultiInsert #  高级参照，多选插入子表。\n在ParamsController中处理它。为true时，会在advanceReferProps中加isMulti和onChange。从而实现了多选自动插入子表。\nif (referParams.enableMultiInsert \u0026amp;\u0026amp; this.presenter.api.isDetailInsertable(detailName)) { referParams[\u0026#39;advanceReferProps\u0026#39;] = Object.assign({}, referParams[\u0026#39;advanceReferProps\u0026#39;], { isMulti: true, onChange: value =\u0026gt; { this.detailController.onAdvanceReferMultipleSelect( detailName, colFieldName, value, rowIndex, referParams, ); }, }); "},{"id":54,"href":"/docs/09.common/%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99/","title":"获取业务规则","section":"九. 通用功能攻略","content":"方式一 #  class ProjectFormPresenter extends EasyBizFormPresenter\u0026lt;IProject\u0026gt;{ private billTypeRules: Array\u0026lt;IBizProcessFuncUnitSetting\u0026gt; = []; xx() { const businessRules = this.bizFormPresenter.api.getBusinessRules() this.billTypeRules = oc(businessRules).rules([]) } } 方式二 #  import { FuncUnit_Constants } from \u0026#39;@q7/athena-gen/src\u0026#39;; class ProjectPlanButton extends MenuButton { private checkEnableProjectRule = () =\u0026gt; { const enableProject: IBizProcessFuncUnitSetting = this.presenter.api.getBusinessRuleById( FuncUnit_Constants.enableProjectScheduleValidator, ); if (enableProject) { return enableProject.setting; } return; }; } 其中FuncUnit_Constants是根据预置数据生成的，可以问后端你要的业务规则的名字。\n业务规则的类型 #  interface IBizProcessFuncUnitSetting { applyTo?: { [key: string]: any } // 应用的对象, \tapplyToTypeObject?: IEnumValue // 应用对象类型, \tbillIoType?: IEnumValue // 单据方向, \tbillType?: IBillType // 单据类型, \tbizObjectInfoWs?: string // 业务对象信息, \tbusinessType?: IBusinessType // 业务类型, \tcreatedTime?: number // 创建时间, \tcreatedUser?: IUser // 创建人, \tcriteria?: { [key: string]: any } // 条件, \tcustomizedFields?: { [key: string]: any } // 自定义属性, \tdataObject?: IObjectType // 对象类型, \tdataVersion?: number // 数据版本, \telseSetting?: { [key: string]: any } // 其他的值, \tentrySrcSystem?: IEnumValue // 数据来源类型, \texternalObjectId?: string // 外部系统唯一标识, \texternalObjectType?: string // 外部系统对象类型, \texternalSystemCode?: string // 外部系统标识, \tfuncUnitBillOfBizProcess?: string // 业务过程处理单元, \tfuncUnit?: IFuncUnit // 功能部件, \tid?: string // ID, \tisDeleted?: boolean // 是否为删除数据, \tisInitData?: boolean // 是否为预置数据, \tisSystem?: boolean // 是否为系统数据, \tlastModifiedTime?: number // 最后修改时间, \tlastModifiedUser?: IUser // 最后修改人, \tlastRequestId?: string // 最后一次更新请求的requestId, \tlistFieldName?: string // 应用的列表字段名, \tmodifiedTime?: number // 修改时间, \tmodifiedUser?: IUser // 修改人, \tobjectTypeObject?: IObjectType // 对象类型, \toverrideModeObject?: IEnumValue // 重载模式, \tsetting?: { [key: string]: any } // 设置, \tsettingDisplayInfo?: string // 描述, \tsourceBillIoType?: IEnumValue // 允许来源的单据方向, \tsourceBillType?: IBillType // 允许来源的单据类型, \tsourceBusinessType?: IBusinessType // 允许来源的业务类型, \tsourceObjectTypeObject?: IObjectType // 允许来源的对象类型, \tuiOption?: { [key: string]: any } // 前端保存的值 } "},{"id":55,"href":"/docs/05.form-guide/init-form/","title":"创建form时带默认数据","section":"五. BizForm实用攻略","content":"场景 #  在新建”项目“时，选择了项目分类后点新建，所选择的分类会出现在表单的”项目分类“中。\n 选择分类 点新建  自动填写了“项目分类”   怎么实现 #    在跳转页面时，将需要的参数放入proxyHistory.push的第二个参数passParams中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class ProjectListPagePresenter extends QueryListPagePresenter\u0026lt; IProjectListPagePresenterOption \u0026gt;{ protected commandActionResolver(commandActions: ToolbarAction[]): ToolbarAction[] { commandActions.unshift({ id: \u0026#39;project-view\u0026#39;, group: ToolbarActionGroup.Group1, action: this.presenter.toolbarConnector.makeCreateButton({ onClick: billTypeId =\u0026gt; { const hash = appRouterHashManager.generateHash(EN_Project, PageModeEnum.Form, { mode: BizFormModeEnum.Create, billTypeId: billTypeId, extraParams: { isBase: this.isBase, }, }); proxyHistory.push(hash, { onSuccess: this.presenter.refresh, category: this.category.curParent,  }); }, }), }); return commandActions; } }  \n  passParams中的数据会放到formPresenter的option中，取出使用即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class ProjectFormPresenter extends EasyBizFormPresenter\u0026lt;IProject\u0026gt; { private options: IEasyBizFormPresenterOptions;  constructor(options: IEasyBizFormPresenterOptions, private isBase?: boolean) { super(EN_Project, options); this.options = options;  } @autobind protected onFormCreated(form: EntityForm\u0026lt;IProject\u0026gt;, disposers: Lambda[]) { // ...  const stageGroup = form.select(F_Project_stageGroup); if (stageGroup \u0026amp;\u0026amp; stageGroup.required) { form.select(F_Project_enableStage).value = true; } if (this.opotions.passParams.category) { form.select(F_Project_category).value = this.options.passParams.category;  } if (this.bizFormPresenter.api.mode === \u0026#39;Copy\u0026#39;) { const clearFields = [ \u0026#39;startDate\u0026#39;, \u0026#39;closedDate\u0026#39;, \u0026#39;changedReason\u0026#39;, \u0026#39;lastChangedTime\u0026#39;, // ...  } }  \n  "},{"id":56,"href":"/docs/07.component/tablist/","title":"TabList","section":"七. 组件","content":"\u0026lt;TabList focusIndex={this.focusIndex} onTabChange={index =\u0026gt; { }} \u0026gt; \u0026lt;Tab key={1} title=\u0026#34;编码方案\u0026#34; /\u0026gt; \u0026lt;Tab key={2} title=\u0026#34;对照码\u0026#34; /\u0026gt; \u0026lt;/TabList\u0026gt; "},{"id":57,"href":"/docs/06.list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/","title":"查询方案","section":"虚拟字段","content":"a #  开发包，列表方案，查询项。加虚拟字段。\n在go上处理虚拟字段\n参考文件services/query-list/middlewares/entities/budget-model/project-fields.go\n"},{"id":58,"href":"/docs/07.component/grid/","title":"Grid","section":"七. 组件","content":"grid #  grid是前端解决子表和列表的方案，对应的组件是AdvanceGird。\neditOptions #  editOptions下面的editParams会传给单元格的渲染组件\n表单 #  "},{"id":59,"href":"/docs/02.form/mstform/","title":"MSTForm-Form状态管理","section":"二. BizForm基础","content":"随着应用复杂度提升，现在不可避免的就是数据状态管理，现在有很多流行框架，redux、mobx、rxjs等等。不同的解决方案在不同场景下会有明显的优劣势，而我们要做的，就是根据场景来选择合适的方案。\n首先，在我们的应用中，我们聚焦到有大量用户输入的表单场景下，我们有以下硬性需求：\n 维护用户录入的字段值； 不同的字段之间有联动关系，修改一个会导致另外一个发生改变； 不同的字段之间，状态会相互影响，修改一个会导致另外一个不可编辑； 表单要支持校验；  由这些需求可以看到，在这种场景下，数据驱动方式的 mobx 是最佳的解决方案，我们可以通过 observable data + control component 来实现双向同步的 UI 组件。这样就解决了一个字段同步的问题。\n同样，当表单复杂以后，我们更倾向于使用树形结构来管理我们的表单数据。\n综上，我们选用了 mobx-state-tree 作为底层框架，来对表单的数据进行管理。\n同时，我们使用 MSTForm 对 mobx-state-tree 进行扩展，使得每一个数据节点（叶子节点）都从一个 value，变成了带有 ui 状态的对象。\n总结一下，MSTForm 是一个用 树形结构 对表单数据进行管理，并使得每一个数据项（即叶子节点）拥有 ui 状态（disabled、readonly、validator、hasError、errorMessage等等）的解决方案。\nselect #  对于 MSTForm 来说，最重要的 api 就是 select，select 会返回一个 MSTFormField，MSTFormField 是通过代理模式实现的对原叶子节点封装的带有 ui 状态的操作对象。\n编程模式的转变 #  带我们使用 MSTForm 对 表单数据进行封装后，我们会发现，以前针对 ui 层面的操作，现在都会被转化为针对数据状态的操作，即我们提升了数据状态的层级，以更加纯净的方式来书写代码，而数据状态 和 真正 ui 层面的更新，则被封装到了更底层的 Level 中。\n从而，我们实现了从 面向UI编程 到 面向数据状态编程 的过度。\n"},{"id":60,"href":"/docs/05.form-guide/menu-button/menu-%E4%BF%AE%E6%94%B9button/","title":"修改Menu中的Button","section":"Menu Button","content":"向Menu中添加Button #  此攻略会向你介绍如何往查看态的menu中加一个按钮\n已有按钮添加到menu中 #  class xxFormPresenter extends EasyBizFormPresenter { protected getMenuOptions(): MenuOptions { const menus = super.getMenuOptions().menus; // 删改menus数组  return menus; } } 在这里修改menus数组就可以了。\n可以直接往里面添加按钮。也可能要根据权限、是不是变更单等条件过滤掉一些按钮。\n"},{"id":61,"href":"/docs/06.list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E5%88%97%E8%A1%A8/","title":"列表中显示虚拟字段列","section":"虚拟字段","content":"配置虚拟字段 #  列表方案是按一定的条件查出一个列表。这个条件在我们的系统中就是“查询方案”。\n我们查询数据是通过 gql 实现的，查询方案最终会转化为 criteriaStr。\n 进入到开发包中的列表方案。通过 + 加号，就可以添加不同的查询条件。   列表方案都是针对一个entity的，所以查询方案也是针对这个entity的。添加的查询条件根据entity上是否存在field分为两种情况。 其中显示项就是entity上已经存在的field，就是下图这样的。 而虚拟字段就是entity上没有你想要的field作为条件。 需要注意。在这个配置界面，“显示名称”需要先填写英文，确定以后再改成中文，因为我们需要“字段名称”是英文，要在后面的开发中用到。而在最初的配置中的“显示名称”会作为“字段名称”，且字段名称不能修改。 参照和枚举根据需要选择即可。\n虚拟字段的代码开发 #  每个查询条件在最后都会转化成 criteriaStr 片段，最后组装成一个大的 criteriaStr 。对于非虚拟字段，可以通过通用的方式去处理的。虚拟字段需要我们写代码来转化为 criteriaStr 。\n首先，假设你已经配置好了一个虚拟字段abc。然后就要在goServer上对它进行处理了。\n找到目录trek/services/query-list/middlewares/entities，看有没有你的entity的目录，如果没有就创建一个。这里以budget-control-rule-set为例 需要index.go文件和各个虚拟字段.go文件。 index.go文件如下： 每个虚拟字段需要在这里声明。\n虚拟字段.go 这里是 rule-remarks.go ： 把这里面的 ruleRemarks 都替换成你的自定义的字段（比如abc）。\n  12行，声明字段用来接收查询的值。\n  27行，存储查询的值。枚举会传过来选择的枚举的id，字符串就是字符串本体，区间就会有两个值。\n  字符串、枚举：   区间：     33行是查询语句。根据自己的业务，会不一样，它会作为该虚拟字段的子criteriaStr拼到完整的criteriaStr中。\n  "},{"id":62,"href":"/docs/09.common/%E5%8A%9F%E8%83%BD%E6%9D%83%E9%99%90/","title":"功能权限","section":"九. 通用功能攻略","content":"实现 #  使用下面的代码就可以做到查看功能权限\nimport { checkAuth } from \u0026#39;@root/func-auth\u0026#39;; import { FunctionAuthActionType } from \u0026#39;@metadata\u0026#39;; checkAuth(EN_Project, FunctionAuthActionType.View) checkAuth方法 #  checkAuth方法的参数：\n   参数 描述     resourceId 资源id   actionType 权限类型，有新增、查看、导出、打印等等    resourceId可能是entityId，也可能是另外定义的resourceId，在文件packages/athena-gen/src/entity-constants/ResourceConstants.ts中。具体是哪个需要和后端确认。\nactionType的定义在文件apps/link/node_modules/@q7/metadata/src/declare/constants.ts中。摘录到下面。\n/** * 功能权限 Action 集合 */ export enum FunctionAuthActionType { // 新增  Add = \u0026#39;add\u0026#39;, // 查看  View = \u0026#39;view\u0026#39;, // 修改  Update = \u0026#39;update\u0026#39;, // 删除  Delete = \u0026#39;delete\u0026#39;, // 输出  Export = \u0026#39;export\u0026#39;, // 打印  Print = \u0026#39;print\u0026#39;, // 作废  Abort = \u0026#39;abort\u0026#39;, // 弃审  Unapprove = \u0026#39;unapprove\u0026#39;, // 审评  Approve = \u0026#39;approve\u0026#39;, // 执行  Execute = \u0026#39;execute\u0026#39;, // 挂起  Suspend = \u0026#39;suspend\u0026#39;, // 取消挂起  CancelSuspend = \u0026#39;cancelSuspend\u0026#39;, // 关闭  Close = \u0026#39;close\u0026#39;, // 打开  Open = \u0026#39;open\u0026#39;, // 预览  Preview = \u0026#39;preview\u0026#39;, // 附件上传  AttachemetUpload = \u0026#39;attachemetUpload\u0026#39;, // 附件删除  AttachmentDelete = \u0026#39;attachmentDelete\u0026#39;, // 附件预览  AttachmentView = \u0026#39;attachmentView\u0026#39;, // 发布  Publish = \u0026#39;publish\u0026#39;, // 设置  Setup = \u0026#39;setup\u0026#39;, // 变更  Change = \u0026#39;change\u0026#39;, } "},{"id":63,"href":"/docs/06.list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E5%AF%BC%E5%87%BA/","title":"导出","section":"虚拟字段","content":"适用场景：列表中有虚拟字段、自定义渲染的字段\n参考：trek/services/query-list/middlewares/entities/budget-model/report-expression.go\n其中的ReportExpression是打印和导出时用到的sql，\n"},{"id":64,"href":"/docs/09.common/%E6%8E%A5%E5%8F%A3/","title":"接口","section":"九. 通用功能攻略","content":"前端不能直接调用后端提供的rest接口，必须前端请求go，go在请求后端\n一、在 go 上申明后端接口地址 #  在文件 trek/urls/url.go 中声明接口地址\n 位置 trek/urls/url.yaml\n 特别注意新加服务\n 新加服务要在app/go-gen/main/index.go中添加如下代码\n 如库存新加的服务 二. 然后控制台进入 app/go-gen/main 目录 执行 sh gen.sh 命令 #  sh gen.sh url 系统会根据定义的接口申明 在 trek/urls/url.go 上自动生成\n 先声明变量。找你相关的代码块，或者自己创建于给代码块，在其中创建变量。  赋值为后端接口地址。在RefreshUrls方法内，将刚刚的变量赋值。  注：这两步是 gen 根据 url.yaml 自动生成，不用手动操作\n三. 添加 go 的接口 #   文件路径 trek/web/controllers/web-controllers/transparent/index.go\n 第一部分，声明一个接口\n 声明go接口的方法（post、get等） 前端访问go接口的url，如果url中包含参数用花括号 处理方法的名字  第二部分，实现方法处理接口\n 拿到url中参数，请求后端接口 刚刚设置的后端接口地址的变量  四. 前端调用接口 #   文件路径 apps/link/src/api/urls.ts\n 在这个文件里找到自己的entity，如果没有就创建一个，在其中声明一个字段作为接口地址（就是第三步的2）。 然后就可以调接口了，要使用 import client from '@client';\nimport client from '@client'; import { urls } from '@root/api'; ... client.post(`${urls.budgetPlan.over}${accountingDimensionId}`, data); ... "},{"id":65,"href":"/docs/09.common/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/","title":"数据权限","section":"九. 通用功能攻略","content":"前端的gql默认是会按数据权限过滤的。\n如果想忽略数据权限的话，需要在option中加contextObject参数，当这个参数是不在数据权限范围内的实体时，就表示忽略数据权限。\n所以这里以ignoreDataAuth字符串为参数，来达到忽略权限的目的。\n1 2 3 4 5  const dataLoader = new DataLoader(EN_BudgetPlan, [\u0026#39;id\u0026#39;], { criteriaStr: `projectId=\u0026#39;${this.projectId}\u0026#39;`, sorts: [{ name: \u0026#39;createdTime\u0026#39;, isDesending: true }], contextObject: \u0026#39;ignoreDataAuth\u0026#39;, } as IDataLoaderQueryOptions);   "},{"id":66,"href":"/docs/05.form-guide/menu-button/menu-%E6%96%B0%E5%BB%BAbutton/","title":"新建一个MenuButton","section":"Menu Button","content":"向Menu中添加Button #  此攻略会向你介绍如何往查看态表单的menu中加一个按钮\n新建一个menu按钮 #  按下面的步骤就可以创建一个按钮，并把它加到menu中\n 按钮的名字 按钮的Creator函数 声明按钮 声明分组 添加到menu中  给搞一个名字 #  在 apps/link/src/solutions/biz-form/page/menu-buttons/declare.ts 文件中在BizFormMenuButtons对象声明按钮的 id 。\n搞Creator函数创建按钮 #  export const ProjectBudgetCreator = () =\u0026gt; { return { id: BizFormMenuButtons.ProjectBudget, render: () =\u0026gt; { return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;ProjectBudgetButton key={BizFormMenuButtons.ProjectBudget} /\u0026gt; \u0026lt;/React.Fragment\u0026gt; ); }, }; }; 其中的React组件需要自己实现，主要是一个Button组件。要注意模块启用、权限。\n声明按钮 #  有了id和creator函数，就可以声明按钮了。 在 apps/link/src/solutions/biz-form/page/menu-buttons/index.tsx 文件中声明了所有menu按钮的Creator函数。你新创建的按钮也需要在这里声明。\nexport const buildInMenus = { [BizFormMenuButtons.SourcePicking]: SourcePickCreator, [BizFormMenuButtons.ImportConsumeItem]: ImportConsumeItemCreator, } 声明类型 #  相同类型的按钮会放到同一分组。 在 apps/link/src/solutions/biz-form/page/declare.ts 文件的 BizformMenuButtonType 对象中为按钮一个类型。\n把按钮放到menu中 #  class xxFormPresenter extends EasyBizFormPresenter { protected getMenuOptions(): MenuOptions { const menus = super.getMenuOptions().menus; menus.push(buildInMenus.ProjectPlan()); return menus; } } "},{"id":67,"href":"/docs/16.other/%E6%96%B0%E5%BB%BA%E7%A7%9F%E6%88%B7/","title":"新建开发用租户","section":"其他","content":"创建新的租户（账号）的方法如下。\n 去运维平台查询对应环境地址, 查到对应的 qbos 地址, 一般为对应的 5000 端口  登录地址 http://(qbos对应的ip地址):5000/, 输入密码, temp13 可以用 test1 进行登录  进入租户管理点击新建, 按照需求进行勾选. (注意是否要启用多组织) 多组织和内部交易是一起的, 只有有多组织才有内部交易  然后在租户管理页面进行激活, 输入手机号 测试环境支持随机号码, 输入后,通过 gql 查询验证码, 查询 gql 见下 gql 地址为通过运维平台查询 identity 服务, 一般端口为 9999  { VerificationCode(criteriaStr:\u0026quot;verifyIdFlag in ('注册的手机号') and to_char(expiredTime, 'yyyymmddhh24miss') \u0026gt;= to_char(CURRENT_TIMESTAMP, 'yyyymmddhh24miss') and isUsed = 'false'\u0026quot;){ code expiredTime verifyIdFlag } }  进入对应环境登录界面, 点击激活账号, 输入手机号, 点击获取验证码 输入对应的手机号和验证码, 验证码可以通过 gql 进行查询 成功以后，进入系统，用刚刚的手机号登录，密码是123456，会提示密码简单需要重置。 重置的话，需要手机号接收验证码。验证码可以通过gql查到。 。需要把下面链接中的IP地址替换成你的环境对应的（见下一步）。 这里。找到你的环境，环境会有两个IP，看哪个IP有9999这个服务，把对应的IP放到上面的链接中。  在gql中替换掉你的手机号，就可以查到验证码了。然后重置密码，进入系统就可以了。  it(\u0026#39;双色球\u0026#39;, ()=\u0026gt; { let i = 0 let k =0 const result ={} do{ const mulriple=Math.ceil( Math.random()*(5-i)) result[`第${k+1}组`] = getBoxResult().join(\u0026#34; \u0026#34;)+ \u0026#34; 倍数：\u0026#34;+ mulriple; if(i==5){ i++ } else { i+=mulriple } k++ } while (i\u0026lt;5) console.log(result); }); function getBoxResult() { const redBox=[]; const blueBox=[]; while (redBox.length \u0026lt; 6) { let count: number = Math.ceil( Math.random()*33) if(redBox.indexOf(count)\u0026lt;0){ redBox.push(count); } } redBox.sort((a,b)=\u0026gt;a-b); const count1 = Math.ceil( Math.random()*16) blueBox.push(count1 \u0026lt;10? \u0026#39;0\u0026#39;+count1 :count1) return [...redBox.map(item=\u0026gt;item\u0026lt;10?\u0026#39;0\u0026#39;+item:item),...blueBox] } "},{"id":68,"href":"/docs/09.common/entitycrud/","title":"脱离 form 对entity进行 CRUD","section":"九. 通用功能攻略","content":"有时我们需要新增、修改、删除一条entity的数据。但是这个entity又没有开发对应的form，无法通过表单来完成。这时就要用到EntityCRUDHelper了\nimport { EntityCRUDHelper } from \u0026#39;@root/solutions/entity-crud\u0026#39;; EntityCRUDHelper.getInstance().update(EN_BudgetAccountDocImport, data) EntityCRUDHelper提供了create/update/delete等几个方法，可以直接基于entity进行crud操作。\n   方法 参数 描述     create entityName, data 创建一条记录   update entityName, data 修改一条记录    注意事项 #  entity不能是子表。子表必须通过主表创建。\n"}]