<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>二. BizForm基础 on 菜鸟集市</title>
    <link>https://zxp-77hub.github.io/docs/02.form/</link>
    <description>Recent content in 二. BizForm基础 on 菜鸟集市</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 24 Mar 2021 10:44:07 +0800</lastBuildDate><atom:link href="https://zxp-77hub.github.io/docs/02.form/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>什么是BizForm</title>
      <link>https://zxp-77hub.github.io/docs/02.form/what-is-bizform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/02.form/what-is-bizform/</guid>
      <description>Biz是业务的意思，Form是表单的意思，两个词组合起来就是业务表单。业务泛指我们系统要处理的各种业务，比如项目、报销、合同等等。表单比较常见，就是展示或者收集各种信息的页面。这些页面是由前端框架中的BizForm类实现的。
先看一下我们系统中的表单长什么样。
这是展示了一个编辑态和一个查看态。 这里只简单的看一个样子，其他文档会介绍更加详细的、各个状态、各个部分的内容。</description>
    </item>
    
    <item>
      <title>BizForm的组成部分</title>
      <link>https://zxp-77hub.github.io/docs/02.form/%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/02.form/%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</guid>
      <description>表单会有不同的状态。
创建和修改时，表单是可以填写内容的，我们称之为编辑态。
查看、审批时，不能编辑内容，只能看，我们称之为查看态。
查看态 #   表单状态 异步任务异常 menu-buttons rang-walk 主表 审批流 子表 ？不知道  </description>
    </item>
    
    <item>
      <title>子表</title>
      <link>https://zxp-77hub.github.io/docs/02.form/%E5%AD%90%E8%A1%A8/</link>
      <pubDate>Wed, 24 Mar 2021 10:44:07 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/02.form/%E5%AD%90%E8%A1%A8/</guid>
      <description>formPresenter一般都是在路由中初始化的。 业务presenter（都是继承了 EasyBizFormPresenter）的构造器中会调用super， super中会调createItemsPresenters将子表也new出来，让子表保存到 itemsPresenters 中。 可以在业务presenter中遍历 itemsPresenters 通过 itemsPresenter 的 logicPath （子表的path）拿到某个子表对象。</description>
    </item>
    
    <item>
      <title>MSTForm-Form状态管理</title>
      <link>https://zxp-77hub.github.io/docs/02.form/mstform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/02.form/mstform/</guid>
      <description>随着应用复杂度提升，现在不可避免的就是数据状态管理，现在有很多流行框架，redux、mobx、rxjs等等。不同的解决方案在不同场景下会有明显的优劣势，而我们要做的，就是根据场景来选择合适的方案。
首先，在我们的应用中，我们聚焦到有大量用户输入的表单场景下，我们有以下硬性需求：
 维护用户录入的字段值； 不同的字段之间有联动关系，修改一个会导致另外一个发生改变； 不同的字段之间，状态会相互影响，修改一个会导致另外一个不可编辑； 表单要支持校验；  由这些需求可以看到，在这种场景下，数据驱动方式的 mobx 是最佳的解决方案，我们可以通过 observable data + control component 来实现双向同步的 UI 组件。这样就解决了一个字段同步的问题。
同样，当表单复杂以后，我们更倾向于使用树形结构来管理我们的表单数据。
综上，我们选用了 mobx-state-tree 作为底层框架，来对表单的数据进行管理。
同时，我们使用 MSTForm 对 mobx-state-tree 进行扩展，使得每一个数据节点（叶子节点）都从一个 value，变成了带有 ui 状态的对象。
总结一下，MSTForm 是一个用 树形结构 对表单数据进行管理，并使得每一个数据项（即叶子节点）拥有 ui 状态（disabled、readonly、validator、hasError、errorMessage等等）的解决方案。
select #  对于 MSTForm 来说，最重要的 api 就是 select，select 会返回一个 MSTFormField，MSTFormField 是通过代理模式实现的对原叶子节点封装的带有 ui 状态的操作对象。
编程模式的转变 #  带我们使用 MSTForm 对 表单数据进行封装后，我们会发现，以前针对 ui 层面的操作，现在都会被转化为针对数据状态的操作，即我们提升了数据状态的层级，以更加纯净的方式来书写代码，而数据状态 和 真正 ui 层面的更新，则被封装到了更底层的 Level 中。
从而，我们实现了从 面向UI编程 到 面向数据状态编程 的过度。</description>
    </item>
    
  </channel>
</rss>
