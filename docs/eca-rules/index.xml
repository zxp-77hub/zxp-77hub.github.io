<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>三. Eca Rules on 菜鸟集市</title>
    <link>https://zxp-77hub.github.io/docs/eca-rules/</link>
    <description>Recent content in 三. Eca Rules on 菜鸟集市</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 18 Oct 2021 10:28:35 +0800</lastBuildDate><atom:link href="https://zxp-77hub.github.io/docs/eca-rules/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>规则验证</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/%E8%A7%84%E5%88%99%E9%AA%8C%E8%AF%81/</link>
      <pubDate>Mon, 18 Oct 2021 10:28:35 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/%E8%A7%84%E5%88%99%E9%AA%8C%E8%AF%81/</guid>
      <description>验证规则及调试 #   在规则保存成功后，就可以到对应的方案中进行规则验证。
 确认规则被加载 #  1.表单 #   在 bizForm/init 接口中，可以通过 response 是否返回了规则，来验证 规则是否被加载。
 注意❗，目前表单规则中，会返回三部分内容：
 2019年底，在 go 上使用 BizFormRuleManager。AddXXXControl 的规则，id前缀为 &amp;quot;Old-{RuleName}&amp;quot;  2020年底，使用第一版规则工具录入的规则，id前缀为 &amp;quot;{RuleName}-&amp;quot;  使用 ECA Rules 录入的全新规则，id 没有前缀  其中，我们通过配置工具录入的规则，是没有任何前缀的。同时，在多组织后，我们会逐步迁移老代码的规则，敬请各位期待 🤪
调试 #   现阶段，可以通过断点的方式进行调试，目前我们正在推动执行过程数据收集，后续可以根据数据进行问题排查。
 所以规则的运行时代码，都在这里，根据规则名称就可以找到对应的执行代码。所有规则的运行时代码，都会实现 IBizRuleActions 这个接口
/** * @link http://gitlab.q7link.com/front/platform/common-solution/-/blob/feature-multi-org2/src/eca/actions/declare.ts */ export interface IBizRuleActions&amp;lt;T = any&amp;gt; { readonly name: string; schema: JSONSchema7; schemaDefs?: Record&amp;lt;string, JSONSchema7&amp;gt; getExpression?(param: T): RuleFieldItem[] execute(ctx: IRuleActionContext, params: T); } </description>
    </item>
    
    <item>
      <title>基础相关</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Fri, 15 Oct 2021 17:06:04 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/</guid>
      <description>表达式 #   针对每个规则，都实现了表达式
 变量表达式 #     变量 作用 是否允许业务扩展     $root 根节点 ❌   $current 当前节点 ❌   $parent 父节点 ❌   $context 上下文，由场景方案具体指定有哪些属性，通常不允许业务扩展 ❌   $params 参数，通常业务扩展参数定义在这里 ✅   $fn 表达式函数，允许业务扩展 ✅    节点选择器 #  根节点 $root #   来获取当前规则所绑定的节点的根节点。
 ❗❗❗ 注意，不同规则可以绑定在不同节点上，但它们根节点因该相同
详细文档请参考 http://front.q7link.com:3000/docs/biz-rules/docs/eca-rules/get-started/using-expr/using-reference
上下文 $context #   上下文通常指的是在一个技术方案中，由技术方案本身提供的上下文变量，不支持业务扩展。</description>
    </item>
    
    <item>
      <title>ReactiveFieldValidator</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldvalidator/</link>
      <pubDate>Thu, 14 Oct 2021 14:17:38 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldvalidator/</guid>
      <description>ReactiveFieldValidator #   创建一个响应式的字段状态，会根据条件实时添加或删除对应 Validator
 type IReactiveFieldValidatorItem = struct { /** Validator 名称 */ Name string `json:&amp;#34;name&amp;#34;` /** 验证参数 */ Params map[string]interface{} `json:&amp;#34;params&amp;#34;` /** 是否是结构化的 默认是false 如果是false 则 按照实例进行验证 也就是验证加载FormField 实例 如果结构化为true 会剔除实例的影响 直接用logicPath 新增验证 这样的话 就会对当前字表的某一列都有效 */ IsStruct bool `json:&amp;#34;isStruct&amp;#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:&amp;#34;when,omitempty&amp;#34;` /** 是否立即执行 默认值：false */ FireImmediately bool `json:&amp;#34;fireImmediately&amp;#34;` } type IReactiveFieldValidatorParams = struct { /** 目标字段 */ Field string `json:&amp;#34;field&amp;#34;` /** 校验器定义 */ Effect *IReactiveFieldValidatorItem `json:&amp;#34;effect,omitempty&amp;#34;` Effects []*IReactiveFieldValidatorItem `json:&amp;#34;effects,omitempty&amp;#34;` } </description>
    </item>
    
    <item>
      <title>ReactiveFieldComponentProps</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldcomponentprops/</link>
      <pubDate>Thu, 14 Oct 2021 14:16:59 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldcomponentprops/</guid>
      <description>ReactiveFieldComponentProps #   创建一个响应式的透传UI组件Props动作，会自动根据依赖数据实时计算新的 props 结果，并添加到目标字段对应的 UI 组件上
 type IReactiveFieldComponentPropsItem = struct { Props map[string]interface{} `json:&amp;#34;props,omitempty&amp;#34;` IsDestruct bool `json:&amp;#34;isDestruct&amp;#34;` When string `json:&amp;#34;when,omitempty&amp;#34;` FireImmediately bool `json:&amp;#34;fireImmediately,omitempty&amp;#34;` } type IReactiveFieldComponentProps = struct { Field string `json:&amp;#34;field&amp;#34;` Effect *IReactiveFieldComponentPropsItem `json:&amp;#34;effect,omitempty&amp;#34;` Effects []*IReactiveFieldComponentPropsItem `json:&amp;#34;effects,omitempty&amp;#34;` } </description>
    </item>
    
    <item>
      <title>Assignment</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/assignment/</link>
      <pubDate>Thu, 14 Oct 2021 14:16:26 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/assignment/</guid>
      <description>Assignment #   给目标字段进行赋值
 type IAssignmentParams struct { /** * 被赋值字段 */ Field string `json:&amp;#34;field&amp;#34;` /** * 赋值结果，支持表达式 */ Expr string `json:&amp;#34;expr&amp;#34;` } 示例 #  1. 仓库子表初始化默认值 #  { &amp;#34;id&amp;#34;: &amp;#34;d4f0a045-f3c2-4b59-be9d-279edfe08184&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;表体初始化默认值&amp;#34;, &amp;#34;reference&amp;#34;: &amp;#34;miscReceiptItems&amp;#34;, &amp;#34;condition&amp;#34;: { &amp;#34;if&amp;#34;: &amp;#34;$current.editFlag === &amp;#39;add&amp;#39; &amp;amp;&amp;amp; $current.srcObject === undefined&amp;#34; }, &amp;#34;actions&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Assignment&amp;#34;, &amp;#34;params&amp;#34;: { &amp;#34;expr&amp;#34;: &amp;#34;$root.warehouse&amp;#34;, &amp;#34;field&amp;#34;: &amp;#34;warehouse&amp;#34; } } ] } </description>
    </item>
    
    <item>
      <title>FieldValidatorRelations</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/fieldvalidatorrelations/</link>
      <pubDate>Thu, 14 Oct 2021 14:15:46 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/fieldvalidatorrelations/</guid>
      <description>FieldValidatorRelations #   校验规则的字段间关系描述
 type IFieldValidatorRelationsItem = struct { /** * 目标字段 */ Source string `json:&amp;#34;source&amp;#34;` /** * 校验字段 */ Targets []string `json:&amp;#34;targets&amp;#34;` /** * 是否双向影响 * 默认值：false */ Bidirectional bool `json:&amp;#34;bidirectional&amp;#34;` } type IFieldValidatorRelations = struct { Relations []IFieldValidatorRelationsItem `json:&amp;#34;relations&amp;#34;` } 示例 #  1. #  { &amp;#34;name&amp;#34;: &amp;#34;FieldValidatorRelations&amp;#34;, &amp;#34;params&amp;#34;: { &amp;#34;relations&amp;#34;: [ { &amp;#34;bidirectional&amp;#34;: true, &amp;#34;source&amp;#34;: &amp;#34;businessDate&amp;#34;, &amp;#34;targets&amp;#34;: [ &amp;#34;startUsedDate&amp;#34; ] } ] } } </description>
    </item>
    
    <item>
      <title>ReactiveAssignment</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/reactiveassignment/</link>
      <pubDate>Thu, 14 Oct 2021 14:15:05 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/reactiveassignment/</guid>
      <description>ReactiveAssignment #   创建一个响应式的赋值动作，会根据规则中的依赖字段返回实时的新计算结果，并赋给目标字段
 type IReactiveAssignmentEffect = struct { /** 取值表达式 */ Expr string `json:&amp;#34;expr&amp;#34;` /** 当目标字段有值时，根据 overrideExpr 的结果来判断是否需要覆盖 默认值：false */ Override bool `json:&amp;#34;override&amp;#34;` /** 当取值表达式为空时，根据 autoClear 的结果判断是否同步清空 默认值：false */ AutoClear bool `json:&amp;#34;autoClear&amp;#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:&amp;#34;when,omitempty&amp;#34;` /** 是否立即生效 默认值：false */ FireImmediately bool `json:&amp;#34;fireImmediately&amp;#34;` } type IReactiveAssignmentEffectV2 = struct { /** 取值表达式 */ Expr string `json:&amp;#34;expr&amp;#34;` /** 当目标字段有值时，根据 overrideExpr 的结果来判断是否需要覆盖 默认值：false */ Override string `json:&amp;#34;override&amp;#34;` /** 当取值表达式为空时，根据 autoClear 的结果判断是否同步清空 默认值：false */ AutoClear string `json:&amp;#34;autoClear&amp;#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:&amp;#34;when,omitempty&amp;#34;` /** 是否立即生效 默认值：false */ FireImmediately string `json:&amp;#34;fireImmediately&amp;#34;` } type IReactiveAssignmentParams = struct { /** 目标字段 */ Field string `json:&amp;#34;field&amp;#34;` /** 赋值来源 */ Effect *IReactiveAssignmentEffect `json:&amp;#34;effect,omitempty&amp;#34;` Effects []*IReactiveAssignmentEffect `json:&amp;#34;effects,omitempty&amp;#34;` } type IReactiveAssignmentParamsV2 = struct { /** 目标字段 */ Field string `json:&amp;#34;field&amp;#34;` /** 赋值来源 */ Effect *IReactiveAssignmentEffectV2 `json:&amp;#34;effect,omitempty&amp;#34;` Effects []*IReactiveAssignmentEffectV2 `json:&amp;#34;effects,omitempty&amp;#34;` } 示例 #  1.</description>
    </item>
    
    <item>
      <title>头体字段值同步</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/%E5%A4%B4%E4%BD%93%E5%AD%97%E6%AE%B5%E5%80%BC%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Wed, 13 Oct 2021 17:47:15 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/%E5%A4%B4%E4%BD%93%E5%AD%97%E6%AE%B5%E5%80%BC%E5%90%8C%E6%AD%A5/</guid>
      <description>ReactiveMasterToTables #   创建一个响应式的表头同步数据到表体，会根据表头的表达式结果，实时进行同步
 /** * 子表设置 */ type IReactiveMasterToTablesTarget = struct { /** * 子表字段名 */ DataTable string `json:&amp;#34;dataTable&amp;#34;` /** * 同步的列字段名 */ Field string `json:&amp;#34;field&amp;#34;` /** * 数据过滤表达式，类似之前的视图，只有在满足表达式条件下的数据行，会被同步数据 * expr =&amp;gt; boolean, defaultWhen =&amp;gt; ignore disabled | readonly */ ViewName string `json:&amp;#34;viewName,omitempty&amp;#34;` /** * 数据过滤表达式，类似之前的视图，只有在满足表达式条件下的数据行，会被同步数据 * expr =&amp;gt; boolean, defaultWhen =&amp;gt; ignore disabled | readonly */ When string `json:&amp;#34;when,omitempty&amp;#34;` /** * force update all */ Always string `json:&amp;#34;always,omitempty&amp;#34;` } /** * 表头字段同步到子表上 */ type IReactiveMasterToTablesParams = struct { /** * 表头字段表达式 */ SourceValue string `json:&amp;#34;sourceValue&amp;#34;` /** * 子表设置 */ Target *IReactiveMasterToTablesTarget `json:&amp;#34;target,omitempty&amp;#34;` /** * 多子表设置（推荐） */ Targets []*IReactiveMasterToTablesTarget `json:&amp;#34;targets,omitempty&amp;#34;` } 字段值</description>
    </item>
    
    <item>
      <title>ReactiveFieldStatus</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldstatus/</link>
      <pubDate>Thu, 30 Sep 2021 10:39:28 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldstatus/</guid>
      <description>ReactiveFieldStatus #   创建一个响应式的字段状态，会根据依赖数据实时返回新状态，并添加到目标字段上
 type IReactiveFieldStatusEffect = struct { /** 状态名称 目前支持：Readonly、Required */ Status string `json:&amp;#34;status&amp;#34;` /** 状态值表达式 */ Expr interface{} `json:&amp;#34;expr&amp;#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:&amp;#34;when,omitempty&amp;#34;` /** 是否立即生效 默认值：false */ FireImmediately bool `json:&amp;#34;fireImmediately&amp;#34;` } type IReactiveFieldStatusParams = struct { /** 目标字段 */ Field string `json:&amp;#34;field&amp;#34;` /** 状态设置 */ Effect *IReactiveFieldStatusEffect `json:&amp;#34;effect,omitempty&amp;#34;` Effects []*IReactiveFieldStatusEffect `json:&amp;#34;effects,omitempty&amp;#34;` } 示例 #  1. 当创建组织为空时，startPeriod 字段禁用 #  { &amp;quot;name&amp;quot;: &amp;quot;ReactiveFieldStatus&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;描述处理的场景&amp;quot;, &amp;quot;params&amp;quot;: { &amp;quot;effect&amp;quot;: { &amp;quot;expr&amp;quot;: &amp;quot;true&amp;quot;, // &amp;quot;fireImmediately&amp;quot;: true, // 是否立即执行 &amp;quot;status&amp;quot;: &amp;quot;Readonly&amp;quot;, // Readonly，Required &amp;quot;when&amp;quot;: &amp;quot;$root.</description>
    </item>
    
  </channel>
</rss>
