<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>菜鸟集市</title>
    <link>https://zxp-77hub.github.io/</link>
    <description>Recent content on 菜鸟集市</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 08 Jul 2021 17:02:03 +0800</lastBuildDate><atom:link href="https://zxp-77hub.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>初入新手村</title>
      <link>https://zxp-77hub.github.io/docs/base/%E5%88%9D%E5%85%A5%E6%96%B0%E6%89%8B%E6%9D%91/</link>
      <pubDate>Tue, 06 Apr 2021 11:44:40 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/base/%E5%88%9D%E5%85%A5%E6%96%B0%E6%89%8B%E6%9D%91/</guid>
      <description>一、VPN #   申请vpn    等陈欢把vpn的证书发过来。
  安装openvpn，应用证书。
  二、安装环境 #  注意事项：
 go环境的目录结构，GOROOT/src/ metadata项目的名字，git仓库名和本地文件名不一样 go的证书  </description>
    </item>
    
    <item>
      <title>GQL</title>
      <link>https://zxp-77hub.github.io/docs/common/gql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/gql/</guid>
      <description>普通的gql #  最简单的，直接查一个对象（表）的全部数据
{ BudgetAccount{ id name accountType { id name } } } 加一点查询条件
{ BudgetAccount(criteriaStr:&amp;quot;name in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)&amp;quot;){ id name accountType { id name } } } 这个会查到name为1、2、3的多条数据
高级的gql #  上面只能查到一个表的数据及其关联的外键，子表的数据。下面来搞一个子查询。
 因为有的时候，后端的模型中，没有包含我们需要的子表，只能我们自己构建
 { BudgetAccount(criteriaStr:&amp;quot;&amp;quot;){ a: exprField(expr:&amp;quot;()&amp;quot;) b: exprField(expr:&amp;quot;()&amp;quot;) } } 其中a:是个模型上的一个字段起别名，exprField是一个可以扩展的额外字段，利用这两个就可以做成子查询了。
举个例子。对于预算指标，复合指标有若干个子指标，但是直接通过BudgetIndicator模型获取不到它们。就可以这样做
{ BudgetIndicator(criteriaStr:&amp;quot;isComposite=true&amp;quot;){ id isComposite child: exprField(expr:&amp;quot;(select string_agg(CONCAT_WS(&#39;,&#39;,childIndicator.id,childIndicator.name),&#39;;&#39;) from BudgetIndicatorComposition where parentIndicatorId=m.id)&amp;quot;) } } 这里使用了两个sql函数把多条记录、多个字段组合成了一个字符串。拿到数据后前端经过简单的split转化就可以拿到json对象了。
常用的sql函数 #  string_agg: 如果查出来有多条结果，会将它们拼装为一个字符串
例子：string_agg(object.name, &#39;, &#39;)
coalesce：如果alias存在则取alias，不存在取name</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>https://zxp-77hub.github.io/posts/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/posts/creating-a-new-theme/</guid>
      <description>Introduction #  This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&#39;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&#39;t cover using CSS to style your theme.
We&#39;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Jekyll</title>
      <link>https://zxp-77hub.github.io/posts/migrate-from-jekyll/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/posts/migrate-from-jekyll/</guid>
      <description>Move static content to static #  Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png  should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png  Additionally, you&#39;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description>
    </item>
    
    <item>
      <title>模型、entity与元数据</title>
      <link>https://zxp-77hub.github.io/docs/base/entity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/base/entity/</guid>
      <description>模型 #  我们系统的后端是领域模型驱动的。比如下图是预算编制方案的模型，其中包含了很多实体(entity)(蓝色的)。 entity #  一个entity就是一个对象，可以通过模型看到各个属性的名字和类型，以及entity之间的关系。
我们前端的工作就是为entity制作表单和列表，来创建entity的实例或展示entity的信息。
元数据 #  前端的元数据主要是对entity的描述。entity的名字、entity的属性名、属性类型等等。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/base/%E9%A2%84%E7%BD%AE%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/base/%E9%A2%84%E7%BD%AE%E6%95%B0%E6%8D%AE/</guid>
      <description>什么是预置数据 #  预置数据可以理解为软件的出厂自带数据，当用户第一次拿到系统时，就存在于系统中的数据。
在预置数据的基础上，用户可以对它们进行修改，也可以添加自己的数据。我们把修改和添加的数据叫做用户数据。
系统中有很多种预置数据。
比如，菜单、查询方案、列表方案
用户可以自己新加几个菜单选项。可以修改查询方案中的字段。可以修改列表方案中显示的列、显示的宽度。等等
预置数据与开发的关系 #  通常，预置数据都会在需求中提到，由产品提供。有些预置数据是后端直接放到数据库里的，前端通过gql取。还有一些是前端在前端开发包里面配置的，这就涉及到了查询方案、列表方案、参照、全局搜索、移动端模板等场景。
将预置数据预置到系统中 #  开发预置的数据是在当前租户的或登录租户的。系统的其他租户是没有这份预置数据的。所以我们需要有一个将预置数据预置到系统中的操作。
 记录一下自己预置了什么（表单、老列表、多列表） 把需要预置的数据的信息整理好，发给曾天保同学。其中几个信息如何获取会在下面介绍。  预置表单 环境: release 后端分支: release 预置租户: PSE5KP504EN000F 改了 Project 预置老列表 环境: test 后端分支: feature-budget-iteration-3rd 预置租户: A24SJR50KMK001E 改了 ProjectMemberView 预置多列表 环境: release 后端分支: release 登录租户id: NSKDNT50NVS002J 多列表方案名称: Project_list 预置租户id：在ops的环境信息中，各个环境都会有预置租户id 登录租户id：打开系统，打开开发者工具network，随便选一个请求，其中header中改回有一个租户id，这就是登陆租户id。 </description>
    </item>
    
    <item>
      <title>什么是BizForm</title>
      <link>https://zxp-77hub.github.io/docs/form/what-is-bizform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form/what-is-bizform/</guid>
      <description>Biz是业务的意思，Form是表单的意思，两个词组合起来就是业务表单。业务泛指我们系统要处理的各种业务，比如项目、报销、合同等等。表单比较常见，就是展示或者收集各种信息的页面。这些页面是由前端框架中的BizForm类实现的。
先看一下我们系统中的表单长什么样。
这是展示了一个编辑态和一个查看态。 这里只简单的看一个样子，其他文档会介绍更加详细的、各个状态、各个部分的内容。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E7%A9%BF%E9%80%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E7%A9%BF%E9%80%8F/</guid>
      <description>穿透 #  我比较喜欢叫它超链接，就是点击列表上的单元格会跳到其他页面的功能。
在这里展示了两种需求：
 会跳到当前单据类型（项目计划）的单据详情页 会跳到其他单据类型（项目）的单据详情页。  代码实现 #    使用rowActionController.makeRowEditAction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class BudgetModelList extends QueryListPagePresenter { { protected getListOption(): IListOption { const listOption = super.getListOption(); return merge(listOption, { gridOption: { actionColumnOption: { visibleSize: 3, }, columnResolver: columnDefs =&amp;gt; { this.</description>
    </item>
    
    <item>
      <title>BizForm的组成部分</title>
      <link>https://zxp-77hub.github.io/docs/form/%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form/%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</guid>
      <description>表单会有不同的状态。
创建和修改时，表单是可以填写内容的，我们称之为编辑态。
查看、审批时，不能编辑内容，只能看，我们称之为查看态。
查看态 #   表单状态 异步任务异常 menu-buttons rang-walk 主表 审批流 子表 ？不知道  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E6%89%93%E5%8D%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E6%89%93%E5%8D%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>打印模板 #  通常可以通过“单据设计”功能设置一个打印模板，但是不知道为什么有些字段无法通过这种方式配到，只能通过代码加出来。</description>
    </item>
    
    <item>
      <title>视图</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Thu, 08 Jul 2021 17:02:03 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E8%A7%86%E5%9B%BE/</guid>
      <description>适用于表单。
 主表presenter的getDataOptions  dynamicViews: { [F_BudgetAccount_refDocMappings(子表名字)]: &amp;#39;viewName(视图名字)&amp;#39;, }, 子表presenter  // 视图的数据 private viewData = observable.array([]); // 查看态 onFormViewed(form: EntityForm&amp;lt;any&amp;gt;, disposers: IDisposer[]) { this.addView(disposers) } // 编辑态 onFormCreated(form: EntityForm&amp;lt;any&amp;gt;, disposers: IDisposer[]) { this.addView(disposers) } addView = (disposers) =&amp;gt; { this.formPresenter.formController.addDynamicView( this.logicPath, &amp;#39;viewName&amp;#39;, this.viewData, ) disposers.push( // 监听子表的数据变化  reaction( () =&amp;gt; { return this.form.select(this.logicPath).value.slice(); }, this.updateData, { fireImmediately: true }, ), ); } // 将子表数据进行处理后赋值给视图数据 updateData = () =&amp;gt; { const data = this.</description>
    </item>
    
    <item>
      <title>线上调试</title>
      <link>https://zxp-77hub.github.io/docs/common/%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95/</link>
      <pubDate>Wed, 07 Jul 2021 10:06:36 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95/</guid>
      <description>线上系统的url后面加?ui-test=t可以让系统加载source map</description>
    </item>
    
    <item>
      <title>EntityDataTree</title>
      <link>https://zxp-77hub.github.io/docs/common/entitydatatree/</link>
      <pubDate>Tue, 29 Jun 2021 13:41:36 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/entitydatatree/</guid>
      <description>寻找自定义该组件中的gql的方法 #  预算项目列表中的左树用了CustomerCategory组件，它又用了CategoryTree组件，其中又用了EntityDataTree组件，其中又用到了CommonProvider类，最终的gql就是在CommonProvider中生成并使用的。
return client .query&amp;lt;{ data: T[] }&amp;gt;({ query: `query{ data: ${queryBuilder.toString()} }` }) </description>
    </item>
    
    <item>
      <title>坑</title>
      <link>https://zxp-77hub.github.io/docs/multi-org/%E5%9D%91/</link>
      <pubDate>Mon, 28 Jun 2021 14:16:16 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/multi-org/%E5%9D%91/</guid>
      <description>列表的路由不能传path参数 #  文档里说要用renderDocumentListRouters这个方法生成路由，但是不能传path参数指定url。 它的内部用renderDocumentList和renderMultiOrgDocumentList2个方法生成了一个普通列表路由，一个多组织列表的路由。
为了解决传path的问题，可以像下面这样写代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  { ...renderDocumentList({ title: &amp;#39;编制方案设置&amp;#39;, entityName: EN_BudgetModel, groupName: `${EN_BudgetModel}_list`, createPresenter: async options =&amp;gt; { const { BudgetModelList } = await import( &amp;#39;@main/screens/projects/budget/budget-model/list/BudgetModelList&amp;#39; ); return new BudgetModelList({ ...options }); }, }), refreshWhenParamsChanged: true, path: appRouterHashManager.</description>
    </item>
    
    <item>
      <title>外键穿透的自定义点击事件</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E5%A4%96%E9%94%AE%E7%A9%BF%E9%80%8F%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Thu, 06 May 2021 10:59:01 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E5%A4%96%E9%94%AE%E7%A9%BF%E9%80%8F%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  protected onInitialized(formPresenter) { formPresenter.getBean(BeanNames.EventController).on(InternalEvent.onCancel, this.cancel); const isTemplateBill = this.isTemplateBill; if (isTemplateBill) { // 修改外键（项目project）的onClick的穿透的行为。当是计划模板时，穿透到项目模板。  const masterRenderController = this.formPresenter.getBean(BeanNames.MasterRendererController); const billTypeId = this.getBillTypeId(); const options: ForeignKeyLinkRenderOption = { onClick(params: ForeignKeyLinkClickParams) {  if (params.entityName === EN_Project){ const hash = appRouterHashManager.generateHash(&amp;#39;ProjectTemplate&amp;#39;, PageModeEnum.Form as any, { mode: BizFormModeEnum.</description>
    </item>
    
    <item>
      <title>场景值reaction</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E5%9C%BA%E6%99%AF%E5%80%BCreaction/</link>
      <pubDate>Mon, 26 Apr 2021 17:49:17 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E5%9C%BA%E6%99%AF%E5%80%BCreaction/</guid>
      <description>如果表单的A字段设置了reaction监听。当修改A的value的时候，对应的reaction都会触发。如果希望不触发reaction，就要用到下面的场景值reaction
// 根据场景值忽略执行的reaction const reactionOmit = this.bizFormPresenter.api.reactionOmitCreator( BizFormScenarios.SourcePicking, ); // 使用reactionOmit监听 disposers.push( reactionOmit( () =&amp;gt; form.select(&amp;#39;F_TimesheetLine_orgRoleType&amp;#39;).value, value =&amp;gt; { } ) ) // 使用reactionOmit对应的场景值赋值，就不会触发reaction this.bizFormPresenter.api.runInScenarios(BizFormScenarios.SourcePicking, () =&amp;gt; { rowField.select(F_TimesheetLine_orgRoleType).value = { id: EN_Department, title: &amp;#39;部门&amp;#39;, name: EN_Department, }; }) </description>
    </item>
    
    <item>
      <title>表头字段自定义渲染</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E8%A1%A8%E5%A4%B4%E5%AD%97%E6%AE%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Mon, 26 Apr 2021 15:58:49 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E8%A1%A8%E5%A4%B4%E5%AD%97%E6%AE%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93/</guid>
      <description>表单中配置masterRender可以实现表头字段的自定义渲染，但是外键字段不能通过masterRender处理。
在MasterRendererController.tsx中有一段代码
const after: IMasterFieldRender[] = [new LinkRender(), new ForeignKeyLinkRender(), new CommonFieldRender()]; 外键字段会走到ForeignKeyLinkRender组件，而masterRender只在CommonFieldRender中才有使用。
protected getDisplayOptions(): DisplayOptions { return { masterRender: { [&amp;#39;project&amp;#39;]: props =&amp;gt; { const LinkDiv = styled.div` height: 100%; display: flex; align-items: center; padding-left: 8px; cursor: pointer; color: var(--primary-500); text-decoration: underline; text-underline-position: under; ` return ( &amp;lt;MSTFormElement label={props.template.title} path={&amp;#39;project&amp;#39;} colspan={1} disableError={true} disabled={true} isRequired={false} labelResolver={value =&amp;gt; value[&amp;#39;project&amp;#39;]} // value 对应的 path={...}中的值 contentRenderer={() =&amp;gt; { const data = props.form.value.project return ( &amp;lt;LinkDiv&amp;gt; &amp;lt;span onClick={async () =&amp;gt; { const hash = appRouterHashManager.</description>
    </item>
    
    <item>
      <title>按钮权限</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90/</link>
      <pubDate>Mon, 26 Apr 2021 15:38:47 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90/</guid>
      <description>多列表方案处理了顶部按钮的权限，但是要在列表方案中指定resourceId
public getQueryListOption(): IQueryListSolutionPresenterOptions { return { ...super.getQueryListOption(), resourceId: &amp;#39;xxxxxxxxxxxxxxx&amp;#39;, }; } </description>
    </item>
    
    <item>
      <title>QueryField</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/queryfield/</link>
      <pubDate>Wed, 14 Apr 2021 18:57:28 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/queryfield/</guid>
      <description>列表数据会查询哪些字段一般是在预置数据里设置的。也可以通过代码控制。
1 2 3 4 5 6 7 8 9 10 11 12 13  export class ProjectConfirmationListListPresenter extends QueryListPagePresenter { getQueryListOption(): IQueryListSolutionPresenterOptions { return { ...super.getQueryListOption(), resourceId: ResourceConstants.Res_ProjectConfirmation, getDynamicQueryFields: () =&amp;gt; { return [&amp;#39;task.project.id&amp;#39;]; }  }; } }   </description>
    </item>
    
    <item>
      <title>行按钮rowAction</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E8%A1%8C%E6%8C%89%E9%92%AErowaction/</link>
      <pubDate>Wed, 14 Apr 2021 18:43:40 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E8%A1%8C%E6%8C%89%E9%92%AErowaction/</guid>
      <description>适用于：多列表
效果图： export class BudgetModelList extends QueryListPagePresenter { // 覆盖父类的方法  getRowActions(rowIndex: number, data: any): IGridAction[] { // 获取公共默认的actions  const actions = this.presenter.listSolutionConnector.rowActionController.makeDefaultRowActions( data, ); if (data &amp;amp;&amp;amp; data.id) { // 加新的按钮  actions.push({ icon: ICON_VIEW, title: &amp;#39;预览&amp;#39;, key: &amp;#39;preview&amp;#39;, onClick: (rowIndex, data) =&amp;gt; this.preview(data), }); } // 还可以对actions数组进行过滤  return actions; } } </description>
    </item>
    
    <item>
      <title>自定义单据</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E6%8D%AE/</link>
      <pubDate>Tue, 13 Apr 2021 21:07:54 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E6%8D%AE/</guid>
      <description>两部分组成：
 创建form form组件  function createForm(): EntityForm { const formScheme = { closeDate: { type: FieldTypeEnum.Timestamp, initState: { label: &amp;#39;关闭日期&amp;#39;, required: false, visible: false, }, }, closedReason: { type: FieldTypeEnum.JsonObject, referType: EN_BizReason, initState: { label: &amp;#39;关闭原因&amp;#39;, required: false, visible: false, }, }, closedReasonExplain: { type: FieldTypeEnum.String, initState: { label: &amp;#39;关闭原因说明&amp;#39;, required: false, visible: false, }, }, }; const formBuilder = new FormBuilder(); Object.entries(formScheme).forEach(([key, value]) =&amp;gt; { formBuilder.appendField(key, makeField(value)); }); return formBuilder.</description>
    </item>
    
    <item>
      <title>选中行</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E9%80%89%E4%B8%AD%E8%A1%8C/</link>
      <pubDate>Tue, 13 Apr 2021 21:06:01 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E9%80%89%E4%B8%AD%E8%A1%8C/</guid>
      <description>适用于：多列表方案
this.presenter.listSolutionConnector.selectionItems </description>
    </item>
    
    <item>
      <title>顶部按钮ToolbarAction</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE/</link>
      <pubDate>Tue, 13 Apr 2021 20:55:08 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE/</guid>
      <description>适用于：多列表方案
效果图： export class ProjectListPagePresenter extends QueryListPagePresenter{ protected commandActionResolver(commandActions: ToolbarAction[]): ToolbarAction[] { // 简单的action  commandActions.unshift({ id: &amp;#39;project-view&amp;#39;, group: ToolbarActionGroup.Group1, action: this.presenter.toolbarConnector.makeCreateButton({ onClick: billTypeId =&amp;gt; { }, }), }); // 复杂的action  commandActions.push(new ProjectMultiCloseAction(this.presenter.listSolutionConnector)) } }  覆盖父类的commandActionResolver方法。向参数commandActions数组中添加ToolbarAction元素即可。 ToolbarAction有两种方式创建。 简单的话，可以用对象字面量创建。 复杂的话，就用一个对象来实现ToolbarAction。参考ProjectMultiCloseAction  </description>
    </item>
    
    <item>
      <title>GridRowAction的popover</title>
      <link>https://zxp-77hub.github.io/docs/common/gridrowaction%E7%9A%84popover/</link>
      <pubDate>Thu, 01 Apr 2021 18:45:12 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/gridrowaction%E7%9A%84popover/</guid>
      <description>多列表方案中
getRowActions(rowIndex: number, data: any): IGridAction[] { const actions = this.presenter.listSolutionConnector.rowActionController.makeDefaultRowActions( data, ); const disabledTimeAction = { icon: &amp;#39;icontuichu&amp;#39;, title: &amp;#39;停用日期&amp;#39;, key: &amp;#39;disabledDate&amp;#39;, onClick: () =&amp;gt; {}, popoverRender: () =&amp;gt; { return { content: ( &amp;lt;div /&amp;gt; ), }; }, } } </description>
    </item>
    
    <item>
      <title>编辑或显示数字精度</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E7%BC%96%E8%BE%91%E6%88%96%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6/</link>
      <pubDate>Thu, 01 Apr 2021 18:19:56 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E7%BC%96%E8%BE%91%E6%88%96%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6/</guid>
      <description>控制编辑，设置editParams
public getEditOptions(): EditOptions { return { editParams: { [主表字段名]: () =&amp;gt; { return { numericProps: { decimalPlaces: 精度, minimumValue: &amp;#39;0&amp;#39;, } } }, [`子表名.子表字段名`]: () =&amp;gt; { return { numericProps: { decimalPlaces: 精度, minimumValue: &amp;#39;0&amp;#39;, } } }, } } } 控制显示，子表要自定义渲染
getGridOptions(): Optional&amp;lt;AdvanceGridProps&amp;gt; { return { columnResolver: (colDefs: ColDef[]) =&amp;gt; { const daysField = colDefs.find(c =&amp;gt; c.field === F_TimesheetLine_days); if (daysField) { daysField.cellRendererFramework = (params) =&amp;gt; { return React.</description>
    </item>
    
    <item>
      <title>水印</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E6%B0%B4%E5%8D%B0/</link>
      <pubDate>Wed, 31 Mar 2021 16:28:22 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E6%B0%B4%E5%8D%B0/</guid>
      <description>go项目
 trek/services/form-services/middlewares/entities/【实体名】/params.go  // 1. 实体的哪些字段要作为水印 var watermarkFieldNames = []string{ gen_ef.F_Project_billFullStatusObject, gen_ef.F_Project_budgetStatus, } var ( // 2. 	watermarkSettingParams = form_service_middlewares_common.WatermarkSettingMiddlewareCreatorParams{ Items: form_service_middlewares_common.DefaultWatermarkSettingItemsCreator(watermarkFieldNames...), } // 3. 	billCommonRulesParams = form_service_middlewares_common.BillCommonRulesCreatorParams{ WatermarkSettingMiddlewareCreatorParams: &amp;amp;watermarkSettingParams, } ) trek/services/form-services/middlewares/entities/【实体名】/index.go  func GetMiddlewareCreators() []form_context.FormMiddlewareCreator { middlewareCreators := []form_context.FormMiddlewareCreator{ // 1. 	form_service_middlewares_common.BillCommonRulesMiddlewareCreator(billCommonRulesParams), } } </description>
    </item>
    
    <item>
      <title>子表</title>
      <link>https://zxp-77hub.github.io/docs/form/%E5%AD%90%E8%A1%A8/</link>
      <pubDate>Wed, 24 Mar 2021 10:44:07 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form/%E5%AD%90%E8%A1%A8/</guid>
      <description>formPresenter一般都是在路由中初始化的。业务presenter（都是继承了 EasyBizFormPresenter）的构造器中会调用super，super中会调createItemsPresenters将子表也new出来，让子表保存到 itemsPresenters 中。可以在业务presenter中遍历 itemsPresenters 通过 itemsPresenter 的 logicPath （子表的path）拿到某个子表对象。</description>
    </item>
    
    <item>
      <title>提示</title>
      <link>https://zxp-77hub.github.io/docs/common/%E6%8F%90%E7%A4%BA/</link>
      <pubDate>Mon, 22 Mar 2021 17:37:07 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E6%8F%90%E7%A4%BA/</guid>
      <description>import { showError, showInfo, showSuccess } from &amp;#39;@root/common/toaster&amp;#39;; showSuccess(&amp;#39;text&amp;#39;) 自适应内容高度的提示
// apps/link/src/main/screens/projects/budget/budget-account/presenter/budget-account-form-presenter/helper.tsx  AlphaWarning( &amp;#39;text&amp;#39;, () =&amp;gt; {}, () =&amp;gt; {}, ); </description>
    </item>
    
    <item>
      <title>Value</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/value/</link>
      <pubDate>Wed, 17 Mar 2021 17:01:44 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/value/</guid>
      <description>Presenter.api.formController.form.select(&#39;modelSubtables/0/dimensions/2&#39;).value
Presenter.api.formController.form.getSubmitValue()</description>
    </item>
    
    <item>
      <title>币种精度</title>
      <link>https://zxp-77hub.github.io/docs/common/%E5%B8%81%E7%A7%8D%E7%B2%BE%E5%BA%A6/</link>
      <pubDate>Wed, 17 Mar 2021 11:53:41 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E5%B8%81%E7%A7%8D%E7%B2%BE%E5%BA%A6/</guid>
      <description>import { store } from &amp;#39;@models&amp;#39;; // 表单中(EasyBizFormPresenter) this.localCurrency.precision // 不在EasyBizFormPresenter中 store.exchangeDefManager.getLocalCurrency().precision </description>
    </item>
    
    <item>
      <title>全貌统计加指标</title>
      <link>https://zxp-77hub.github.io/docs/common/%E5%85%A8%E8%B2%8C%E7%BB%9F%E8%AE%A1%E5%8A%A0%E6%8C%87%E6%A0%87/</link>
      <pubDate>Tue, 16 Mar 2021 11:27:50 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E5%85%A8%E8%B2%8C%E7%BB%9F%E8%AE%A1%E5%8A%A0%E6%8C%87%E6%A0%87/</guid>
      <description>https://shimo.im/sheets/16q8MDar7Ktv0mk7/cayv7，所有的指标会在这个文档里说明。其中【指标编码】是下文中提到的 MeasureId 。
需要现在go上配置好指标，然后在前端中获取指标并进行设置。
go #   trek/services/dashboard/config/project-overview.go addProjectStatisticsConfig函数 addConfig  // 多值指标 addConfig(&amp;amp;dashboard.EvaluateCardConfig{ Id: &amp;#34;projectTimeStatisticCost&amp;#34;, Title: &amp;#34;工时成本&amp;#34;, Icon: &amp;#34;icongongshi1&amp;#34;, ViewType: dashboard.CardViewType_MultiValue, ValueConfig: []dashboard.EvaluateValueConfig{ { Id: &amp;#34;workingTimeCost&amp;#34;, Icon: &amp;#34;iconzonggongshi&amp;#34;, Title: &amp;#34;总工时成本&amp;#34;, MeasureId: &amp;#34;workingTimeCost&amp;#34;, Unit: dashboard.CardViewUnit_TenThounsand, ClassName: &amp;#34;color1&amp;#34;, SupportPenetrate: true, IsAmount: true, ValuePeriodType: dashboard.MeasurePeriodValueTypeOccurs, }, } }) // 单值指标 addConfig(&amp;amp;dashboard.EvaluateCardConfig{ Id: &amp;#34;workingTimeCost&amp;#34;, Title: &amp;#34;总工时成本&amp;#34;, Icon: &amp;#34;&amp;#34;, ViewType: dashboard.CardViewType_SingleValue, ValueConfig: dashboard.EvaluateValueConfig{ Id: &amp;#34;count&amp;#34;, Icon: &amp;#34;iconzonggongshi&amp;#34;, Title: &amp;#34;总工时成本&amp;#34;, MeasureId: &amp;#34;workingTimeCost&amp;#34;, Unit: dashboard.CardViewUnit_TenThounsand, IsAmount: true, ClassName: &amp;#34;color1&amp;#34;, SupportPenetrate: true, ValuePeriodType: dashboard.</description>
    </item>
    
    <item>
      <title>模块启用</title>
      <link>https://zxp-77hub.github.io/docs/common/%E6%A8%A1%E5%9D%97%E5%90%AF%E7%94%A8/</link>
      <pubDate>Thu, 11 Mar 2021 11:01:34 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E6%A8%A1%E5%9D%97%E5%90%AF%E7%94%A8/</guid>
      <description>go #  go项目，获取功能权限是否开启
b := ctx.GetBusinessModuleById(gen_ec.EC_BusinessModule_BusinessModule_budget) // b.IsEnabled 前端 #  import { store } from &amp;#39;@models&amp;#39;; class A { b() { const contractModel = store.moduleInitManager.getModuleById(&amp;#39;BusinessModule_contract&amp;#39;); if ( !contractModel || !contractModel.isEnabled ) { // ...  } } } </description>
    </item>
    
    <item>
      <title>Gen</title>
      <link>https://zxp-77hub.github.io/docs/common/gen/</link>
      <pubDate>Wed, 10 Mar 2021 17:41:36 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/gen/</guid>
      <description>http://172.31.23.98:8080/job/front-gen/
gen:
 在app/go-gen中修改main/index.go中的ApiHost变量为你环境的host，运行gen.sh； 提交代码，部署trek到目标环境； 在jinkens的front-gen中，左边的Build with Parameters生成目标分支、目标环境的web的gen； 获取PR地址，修改remote分支，默认是master，合并代码  问题 #   某些变量在本地跑完gen后不见了  可能是后端该了某些属性的名字，但是0租户没有同步。    </description>
    </item>
    
    <item>
      <title>获取系统参数</title>
      <link>https://zxp-77hub.github.io/docs/common/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0/</link>
      <pubDate>Tue, 09 Mar 2021 15:48:33 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0/</guid>
      <description>一 #  先在go上设置需要得系统参数，然后在前端取用。 参考：
 trek/services/form-services/middlewares/entities/time-sheet/index.go apps/link/src/main/screens/projects/time-sheet/form/TimeSheetFormPresenter.tsx  // 这里定义需要查询的系统参数 form_service_middlewares_creators.AppendSystemSettingKeyMiddlewareCreator( form_service_middlewares_creators.AppendSystemSettingKeyParams{ Keys: []string{ gen_ec.EC_Setting_timsheetWeekStarts, gen_ec.EC_Setting_timesheetPrecision, gen_ec.EC_Setting_timsheetDay2Hour, gen_ec.EC_Setting_timesheetCostRateType, gen_ec.EC_Setting_priceScale, }, }, ), this.bizFormPresenter.api.getSystemSetting(&amp;#39;timesheetCostRateType&amp;#39;); 二 #  const key = &amp;#39;timesheetCostRateType&amp;#39;; // 参数名 const settingDataLoader = new DataLoader(EN_Setting, [&amp;#39;values.value&amp;#39;], { criteriaStr: `key=&amp;#39;${key}&amp;#39;`, } as QueryOptions); const data = await settingDataLoader.query(); const result = data[0]; // result.value就是该参数的值  </description>
    </item>
    
    <item>
      <title>AllPaths</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/allpaths/</link>
      <pubDate>Mon, 08 Mar 2021 15:38:59 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/allpaths/</guid>
      <description>bizFormPresenter.api.formController.entityCRUD.allPaths bizFormPresenter.api.getForm().select(&#39;timesheetLines/0/indvRole&#39;) </description>
    </item>
    
    <item>
      <title>查询项的默认值</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/%E6%9F%A5%E8%AF%A2%E9%A1%B9%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/</link>
      <pubDate>Mon, 01 Mar 2021 14:29:52 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/%E6%9F%A5%E8%AF%A2%E9%A1%B9%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/</guid>
      <description>这里介绍如何为查询项设置默认值。 参看：trek/services/query-list/middlewares/entities/project-schedule/query-default-value.go
主要的代码是这段
func (m *billStatusObjectMiddleware) QueryDefHandler(ctx query_list.QueryListContext, api query_list.QueryDefApi) { schema := api.GetQueryItemSchema(billStatusObjectFieldName) if schema != nil { defaultVal := map[string]interface{}{ &amp;#34;values&amp;#34;: []defItem{ { Title: &amp;#34;已生效&amp;#34;, Id: &amp;#34;BillStatus.effective&amp;#34;, }, }, } api.SetDefaultValue(billStatusObjectFieldName, defaultVal) schema.OperatorId = gen_enums.ENUM_CriteriaOperator_in schema.Operator = ctx.GetContext().GetMetadata().GetEnumValue(gen_enums.ENUM_CriteriaOperator, gen_enums.ENUM_CriteriaOperator_in) } } </description>
    </item>
    
    <item>
      <title>单据状态</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E5%8D%95%E6%8D%AE%E7%8A%B6%E6%80%81/</link>
      <pubDate>Fri, 26 Feb 2021 14:29:44 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E5%8D%95%E6%8D%AE%E7%8A%B6%E6%80%81/</guid>
      <description>export const ENUM_BillStatus = &amp;#34;BillStatus&amp;#34;; // 单据状态 export const ENUM_BillStatus_draft = &amp;#34;BillStatus.draft&amp;#34;; // 未提交 export const ENUM_BillStatus_submitting = &amp;#34;BillStatus.submitting&amp;#34;; // 提交中 export const ENUM_BillStatus_submitted = &amp;#34;BillStatus.submitted&amp;#34;; // 已提交 export const ENUM_BillStatus_approving = &amp;#34;BillStatus.approving&amp;#34;; // 审批中 export const ENUM_BillStatus_effecting = &amp;#34;BillStatus.effecting&amp;#34;; // 生效中 export const ENUM_BillStatus_effective = &amp;#34;BillStatus.effective&amp;#34;; // 已生效 export const ENUM_BillStatus_restarting = &amp;#34;BillStatus.restarting&amp;#34;; // 退回中 export const ENUM_BillStatus_restarted = &amp;#34;BillStatus.restarted&amp;#34;; // 已退回 export const ENUM_BillStatus_recalling = &amp;#34;BillStatus.recalling&amp;#34;; // 撤回中 export const ENUM_BillStatus_recalled = &amp;#34;BillStatus.</description>
    </item>
    
    <item>
      <title>删除行</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E5%88%A0%E9%99%A4%E8%A1%8C/</link>
      <pubDate>Mon, 22 Feb 2021 18:20:56 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E5%88%A0%E9%99%A4%E8%A1%8C/</guid>
      <description>const refDocMappingsField = this.form.select(F_BudgetAccount_refDocMappings); if (refDocMappingsField.value !== undefined) { let len = refDocMappingsField.value.length; while (len&amp;gt;0){ this.formController.deleteRowByRealIndex( F_BudgetAccount_refDocMappings, len - 1, ); len --; } } </description>
    </item>
    
    <item>
      <title>查询项</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/%E6%9F%A5%E8%AF%A2%E9%A1%B9/</link>
      <pubDate>Tue, 26 Jan 2021 11:05:11 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/%E6%9F%A5%E8%AF%A2%E9%A1%B9/</guid>
      <description>多列表方案中的 getQueryResolverOptions 方法可以用来设置【查询项】
class BudgetPlanBasePresenter extends QueryListPagePresenter { protected getQueryResolverOptions(queryListDef, option): IQueryModelResolverOptions { return { someKey: onModelCreated: (item: QueryItem) =&amp;gt; { item.value } } } } 数据结构
export interface IQueryModelResolverOptions { [key: string]: IQueryModelItemResolverOptions | IQueryModelItemResolverCreator; } export type IQueryModelItemResolverCreator = (options) =&amp;gt; IQueryModelItemResolverOptions; export interface IQueryModelItemResolverOptions&amp;lt;T = any&amp;gt; { // 显示查询方案时，每次都会触发  onModelCreated?: (item: QueryItem) =&amp;gt; void; baseFieldOptionsResovler?: ( item: IQueryCriteria, options: FieldOptions, ) =&amp;gt; MSTFormOptions[&amp;#39;fieldOptions&amp;#39;] | FieldOptions; baseTypeResolver?: (item: IQueryCriteria, type: IType&amp;lt;any, any, any&amp;gt;) =&amp;gt; IType&amp;lt;any, any, any&amp;gt;; itemFieldOptionsResolver?</description>
    </item>
    
    <item>
      <title>AdvanceDialog</title>
      <link>https://zxp-77hub.github.io/docs/component/advancedialog/</link>
      <pubDate>Wed, 20 Jan 2021 19:00:09 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/component/advancedialog/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import { showDialog, requestDialogId, closeDialog } from &amp;#39;@root/common/dialog&amp;#39;; import { AdvanceDialog } from &amp;#39;@components/advance-dialog/AdvanceDialog&amp;#39;; function renderDialog() { const dialogId = requestDialogId();  showDialog(dialogId, (  &amp;lt;AdvanceDialog isOpen title=&amp;#34;催办&amp;#34; buttons={[{ text: &amp;#39;确定&amp;#39;, onClick: () =&amp;gt; {  closeDialog(dialogId) } }]} onClose={() =&amp;gt; {  closeDialog(dialogId) }} &amp;gt; &amp;lt;/AdvanceDialog&amp;gt; )) }   列宽可以通过鼠标拖动</description>
    </item>
    
    <item>
      <title>刷新列表</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E5%88%B7%E6%96%B0%E5%88%97%E8%A1%A8/</link>
      <pubDate>Fri, 15 Jan 2021 14:34:22 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E5%88%B7%E6%96%B0%E5%88%97%E8%A1%A8/</guid>
      <description>场景 #  有时我需要刷新列表，比如，在列表上面的工具栏中加个按钮，按钮会搞了一个弹窗出来修改数据；比如，新建了一个单据。
实现 #  新老列表的presenter中都实现了refresh方法</description>
    </item>
    
    <item>
      <title>Refer</title>
      <link>https://zxp-77hub.github.io/docs/component/refer/</link>
      <pubDate>Wed, 13 Jan 2021 11:39:09 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/component/refer/</guid>
      <description>form中设置 #  getEditOptions之editParams #  editParams是定义每个field（也可以设置子表的field）的编辑态的参数。
{ [key: fieldName]: 参数对象 } 参数对象需要根据field具体是什么来行确定，比如field可能是数字、字符串、参照等，对应的渲染组件就是NumberField，ReferField，TextField等，参数对象就是对应的渲染组件的参数。
参数 #  // 高级参照支持多选 enableMultiInsert: true, criteriaStr: criteriaStr, referConfigResolver: referConfig =&amp;gt; { return Object.assign({}, referConfig, { displayField: &#39;code&#39;, }); }, advanceReferProps: { categoryCriteriaStr: , }, queryFields: [], onMultiInsert: ( data: Array&amp;lt;ICustomizedCarryoverProgrammeSubjectSetting&amp;gt;, editRowField: MSTFormField, ) =&amp;gt; { if (Array.isArray(data) &amp;amp;&amp;amp; data.length &amp;gt; 0) { const origin = editRowField.value || []; for (let i = 0, len = data.</description>
    </item>
    
    <item>
      <title>获取业务规则</title>
      <link>https://zxp-77hub.github.io/docs/common/%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99/</link>
      <pubDate>Tue, 05 Jan 2021 17:48:57 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99/</guid>
      <description>方式一 #  class ProjectFormPresenter extends EasyBizFormPresenter&amp;lt;IProject&amp;gt;{ private billTypeRules: Array&amp;lt;IBizProcessFuncUnitSetting&amp;gt; = []; xx() { const businessRules = this.bizFormPresenter.api.getBusinessRules() this.billTypeRules = oc(businessRules).rules([]) } } 方式二 #  import { FuncUnit_Constants } from &amp;#39;@q7/athena-gen/src&amp;#39;; class ProjectPlanButton extends MenuButton { private checkEnableProjectRule = () =&amp;gt; { const enableProject: IBizProcessFuncUnitSetting = this.presenter.api.getBusinessRuleById( FuncUnit_Constants.enableProjectScheduleValidator, ); if (enableProject) { return enableProject.setting; } return; }; } 其中FuncUnit_Constants是根据预置数据生成的，可以问后端你要的业务规则的名字。
业务规则的类型 #  interface IBizProcessFuncUnitSetting { applyTo?: { [key: string]: any } // 应用的对象, 	applyToTypeObject?</description>
    </item>
    
    <item>
      <title>创建form时带默认数据</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/init-form/</link>
      <pubDate>Tue, 05 Jan 2021 11:25:11 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/init-form/</guid>
      <description>场景 #  在新建”项目“时，选择了项目分类后点新建，所选择的分类会出现在表单的”项目分类“中。
 选择分类 点新建  自动填写了“项目分类”   怎么实现 #    在跳转页面时，将需要的参数放入proxyHistory.push的第二个参数passParams中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class ProjectListPagePresenter extends QueryListPagePresenter&amp;lt; IProjectListPagePresenterOption &amp;gt;{ protected commandActionResolver(commandActions: ToolbarAction[]): ToolbarAction[] { commandActions.unshift({ id: &amp;#39;project-view&amp;#39;, group: ToolbarActionGroup.Group1, action: this.presenter.toolbarConnector.makeCreateButton({ onClick: billTypeId =&amp;gt; { const hash = appRouterHashManager.generateHash(EN_Project, PageModeEnum.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/component/tablist/</link>
      <pubDate>Mon, 04 Jan 2021 23:57:09 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/component/tablist/</guid>
      <description>&amp;lt;TabList focusIndex={this.focusIndex} onTabChange={index =&amp;gt; { }} &amp;gt; &amp;lt;Tab key={1} title=&amp;#34;编码方案&amp;#34; /&amp;gt; &amp;lt;Tab key={2} title=&amp;#34;对照码&amp;#34; /&amp;gt; &amp;lt;/TabList&amp;gt; </description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>https://zxp-77hub.github.io/posts/goisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/posts/goisforlovers/</guid>
      <description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>https://zxp-77hub.github.io/posts/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/posts/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo #  Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs #  Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/component/grid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/component/grid/</guid>
      <description>grid #  grid是前端解决子表和列表的方案，对应的组件是AdvanceGird。
editOptions #  editOptions下面的editParams会传给单元格的渲染组件
表单 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/form-guide/menu-button/%E8%81%94%E6%9F%A5%E6%8C%89%E9%92%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/menu-button/%E8%81%94%E6%9F%A5%E6%8C%89%E9%92%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/</guid>
      <description>a #  </description>
    </item>
    
    <item>
      <title>MSTForm-Form状态管理</title>
      <link>https://zxp-77hub.github.io/docs/form/mstform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form/mstform/</guid>
      <description>随着应用复杂度提升，现在不可避免的就是数据状态管理，现在有很多流行框架，redux、mobx、rxjs等等。不同的解决方案在不同场景下会有明显的优劣势，而我们要做的，就是根据场景来选择合适的方案。
首先，在我们的应用中，我们聚焦到有大量用户输入的表单场景下，我们有以下硬性需求：
 维护用户录入的字段值； 不同的字段之间有联动关系，修改一个会导致另外一个发生改变； 不同的字段之间，状态会相互影响，修改一个会导致另外一个不可编辑； 表单要支持校验；  由这些需求可以看到，在这种场景下，数据驱动方式的 mobx 是最佳的解决方案，我们可以通过 observable data + control component 来实现双向同步的 UI 组件。这样就解决了一个字段同步的问题。
同样，当表单复杂以后，我们更倾向于使用树形结构来管理我们的表单数据。
综上，我们选用了 mobx-state-tree 作为底层框架，来对表单的数据进行管理。
同时，我们使用 MSTForm 对 mobx-state-tree 进行扩展，使得每一个数据节点（叶子节点）都从一个 value，变成了带有 ui 状态的对象。
总结一下，MSTForm 是一个用 树形结构 对表单数据进行管理，并使得每一个数据项（即叶子节点）拥有 ui 状态（disabled、readonly、validator、hasError、errorMessage等等）的解决方案。
select #  对于 MSTForm 来说，最重要的 api 就是 select，select 会返回一个 MSTFormField，MSTFormField 是通过代理模式实现的对原叶子节点封装的带有 ui 状态的操作对象。
编程模式的转变 #  带我们使用 MSTForm 对 表单数据进行封装后，我们会发现，以前针对 ui 层面的操作，现在都会被转化为针对数据状态的操作，即我们提升了数据状态的层级，以更加纯净的方式来书写代码，而数据状态 和 真正 ui 层面的更新，则被封装到了更底层的 Level 中。
从而，我们实现了从 面向UI编程 到 面向数据状态编程 的过度。</description>
    </item>
    
    <item>
      <title>修改Menu中的Button</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/menu-button/menu-%E4%BF%AE%E6%94%B9button/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/menu-button/menu-%E4%BF%AE%E6%94%B9button/</guid>
      <description>向Menu中添加Button #  此攻略会向你介绍如何往查看态的menu中加一个按钮
已有按钮添加到menu中 #  class xxFormPresenter extends EasyBizFormPresenter { protected getMenuOptions(): MenuOptions { const menus = super.getMenuOptions().menus; // 删改menus数组  return menus; } } 在这里修改menus数组就可以了。
可以直接往里面添加按钮。也可能要根据权限、是不是变更单等条件过滤掉一些按钮。</description>
    </item>
    
    <item>
      <title>列表中显示虚拟字段列</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E5%88%97%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E5%88%97%E8%A1%A8/</guid>
      <description>配置虚拟字段 #  列表方案是按一定的条件查出一个列表。这个条件在我们的系统中就是“查询方案”。
我们查询数据是通过 gql 实现的，查询方案最终会转化为 criteriaStr。
 进入到开发包中的列表方案。通过 + 加号，就可以添加不同的查询条件。   列表方案都是针对一个entity的，所以查询方案也是针对这个entity的。添加的查询条件根据entity上是否存在field分为两种情况。 其中显示项就是entity上已经存在的field，就是下图这样的。 而虚拟字段就是entity上没有你想要的field作为条件。 需要注意。在这个配置界面，“显示名称”需要先填写英文，确定以后再改成中文，因为我们需要“字段名称”是英文，要在后面的开发中用到。而在最初的配置中的“显示名称”会作为“字段名称”，且字段名称不能修改。 参照和枚举根据需要选择即可。
虚拟字段的代码开发 #  每个查询条件在最后都会转化成 criteriaStr 片段，最后组装成一个大的 criteriaStr 。对于非虚拟字段，可以通过通用的方式去处理的。虚拟字段需要我们写代码来转化为 criteriaStr 。
首先，假设你已经配置好了一个虚拟字段abc。然后就要在goServer上对它进行处理了。
找到目录trek/services/query-list/middlewares/entities，看有没有你的entity的目录，如果没有就创建一个。这里以budget-control-rule-set为例 需要index.go文件和各个虚拟字段.go文件。 index.go文件如下： 每个虚拟字段需要在这里声明。
虚拟字段.go 这里是 rule-remarks.go ： 把这里面的 ruleRemarks 都替换成你的自定义的字段（比如abc）。
  12行，声明字段用来接收查询的值。
  27行，存储查询的值。枚举会传过来选择的枚举的id，字符串就是字符串本体，区间就会有两个值。
  字符串、枚举：   区间：     33行是查询语句。根据自己的业务，会不一样，它会作为该虚拟字段的子criteriaStr拼到完整的criteriaStr中。
  </description>
    </item>
    
    <item>
      <title>功能权限</title>
      <link>https://zxp-77hub.github.io/docs/common/%E5%8A%9F%E8%83%BD%E6%9D%83%E9%99%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E5%8A%9F%E8%83%BD%E6%9D%83%E9%99%90/</guid>
      <description>实现 #  使用下面的代码就可以做到查看功能权限
import { checkAuth } from &amp;#39;@root/func-auth&amp;#39;; import { FunctionAuthActionType } from &amp;#39;@metadata&amp;#39;; checkAuth(EN_Project, FunctionAuthActionType.View) checkAuth方法 #  checkAuth方法的参数：
   参数 描述     resourceId 资源id   actionType 权限类型，有新增、查看、导出、打印等等    resourceId可能是entityId，也可能是另外定义的resourceId，在文件packages/athena-gen/src/entity-constants/ResourceConstants.ts中。具体是哪个需要和后端确认。
actionType的定义在文件apps/link/node_modules/@q7/metadata/src/declare/constants.ts中。摘录到下面。
/** * 功能权限 Action 集合 */ export enum FunctionAuthActionType { // 新增  Add = &amp;#39;add&amp;#39;, // 查看  View = &amp;#39;view&amp;#39;, // 修改  Update = &amp;#39;update&amp;#39;, // 删除  Delete = &amp;#39;delete&amp;#39;, // 输出  Export = &amp;#39;export&amp;#39;, // 打印  Print = &amp;#39;print&amp;#39;, // 作废  Abort = &amp;#39;abort&amp;#39;, // 弃审  Unapprove = &amp;#39;unapprove&amp;#39;, // 审评  Approve = &amp;#39;approve&amp;#39;, // 执行  Execute = &amp;#39;execute&amp;#39;, // 挂起  Suspend = &amp;#39;suspend&amp;#39;, // 取消挂起  CancelSuspend = &amp;#39;cancelSuspend&amp;#39;, // 关闭  Close = &amp;#39;close&amp;#39;, // 打开  Open = &amp;#39;open&amp;#39;, // 预览  Preview = &amp;#39;preview&amp;#39;, // 附件上传  AttachemetUpload = &amp;#39;attachemetUpload&amp;#39;, // 附件删除  AttachmentDelete = &amp;#39;attachmentDelete&amp;#39;, // 附件预览  AttachmentView = &amp;#39;attachmentView&amp;#39;, // 发布  Publish = &amp;#39;publish&amp;#39;, // 设置  Setup = &amp;#39;setup&amp;#39;, // 变更  Change = &amp;#39;change&amp;#39;, } </description>
    </item>
    
    <item>
      <title>后端的接口</title>
      <link>https://zxp-77hub.github.io/docs/common/%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E6%8E%A5%E5%8F%A3/</guid>
      <description>之所以叫“后端的接口”是为了与“go的接口”区分开。
因为前端只能访问到go不能直接访问到后端，所以后端提供的接口，只能通过go访问。那么就要在go上加一个接口，前端访问go的接口，go访问后端的接口。
下面介绍一下实现一个go接口的步骤。
一、声明后端接口地址 #  在文件 trek/urls/url.go 中声明接口地址
比如这样
// 批量设置执行指标 	BudgetBatchSetIndicators := BudgetHost + &amp;#34;/baseapp/BudgetAccount/batchSetIndicators&amp;#34; 其中的 BudgetHost 是服务的地址，可以在文件的开头看到，它是根据具体的服务会有所不同的。
二、添加go的接口 #  找到文件 trek/web/controllers/web-controllers/transparent/index.go
1. 在 BeforeActivation 方法中创建go的接口 #  1 2 3 4 5  func (c *transparentController) BeforeActivation(b mvc.BeforeActivation) { // ...  b.Handle(iris.MethodPost, &amp;#34;/BudgetAccount/batchSetIndicators&amp;#34;, &amp;#34;BudgetAccountBatchSetIndicators&amp;#34;)  // ... }   其中b.Handle 方法的三个参数分别是
 http method go接口url（前端访问的url） go接口的处理函数  2. 实现“处理函数” #  在上面提到的BeforeActivation方法下面，创建一个与它同级的方法，也就是接口处理函数，内容就是直接给后端发起一个请求。
其中第11行是第一步中声明的后端url地址 1 2 3 4 5 6 7 8 9 10 11 12  func (c *transparentController) BeforeActivation(b mvc.</description>
    </item>
    
    <item>
      <title>如何做详设</title>
      <link>https://zxp-77hub.github.io/docs/design/%E5%A6%82%E4%BD%95%E5%81%9A%E8%AF%A6%E8%AE%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/design/%E5%A6%82%E4%BD%95%E5%81%9A%E8%AF%A6%E8%AE%BE/</guid>
      <description>一个功能如何实现？
 改旧的功能  原来怎么实现的 数据从自哪个entity、哪个字段？进行了哪些拼装、组合、转换？   新的功能  公共的支持吗？  用过吗？  怎么用？     非标的吗？如何设计？  如何管理状态、数据？ 数据从自哪个entity、哪个字段？需要拼装、组合、转换吗？ 有哪些数据需要展示？ 哪些数据分给哪个组件？ 组件  能使用哪些公共组件？ 组件需要的参数 内部需要管理状态吗？   保存数据时需要转换数据吗？ 回显时需要转换数据吗？      </description>
    </item>
    
    <item>
      <title>导出</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E5%AF%BC%E5%87%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E5%AF%BC%E5%87%BA/</guid>
      <description>适用场景：列表中有虚拟字段、自定义渲染的字段
参考：trek/services/query-list/middlewares/entities/budget-model/report-expression.go
其中的ReportExpression是打印和导出时用到的sql，</description>
    </item>
    
    <item>
      <title>数据权限</title>
      <link>https://zxp-77hub.github.io/docs/common/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/</guid>
      <description>前端的gql默认是会按数据权限过滤的。
如果想忽略数据权限的话，需要在option中加contextObject参数，当这个参数是不在数据权限范围内的实体时，就表示忽略数据权限。
所以这里以ignoreDataAuth字符串为参数，来达到忽略权限的目的。
1 2 3 4 5  const dataLoader = new DataLoader(EN_BudgetPlan, [&amp;#39;id&amp;#39;], { criteriaStr: `projectId=&amp;#39;${this.projectId}&amp;#39;`, sorts: [{ name: &amp;#39;createdTime&amp;#39;, isDesending: true }], contextObject: &amp;#39;ignoreDataAuth&amp;#39;, } as IDataLoaderQueryOptions);   </description>
    </item>
    
    <item>
      <title>新建一个MenuButton</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/menu-button/menu-%E6%96%B0%E5%BB%BAbutton/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/menu-button/menu-%E6%96%B0%E5%BB%BAbutton/</guid>
      <description>向Menu中添加Button #  此攻略会向你介绍如何往查看态表单的menu中加一个按钮
新建一个menu按钮 #  按下面的步骤就可以创建一个按钮，并把它加到menu中
 按钮的名字 按钮的Creator函数 声明按钮 声明分组 添加到menu中  给搞一个名字 #  在 apps/link/src/solutions/biz-form/page/menu-buttons/declare.ts 文件中在BizFormMenuButtons对象声明按钮的 id 。
搞Creator函数创建按钮 #  export const ProjectBudgetCreator = () =&amp;gt; { return { id: BizFormMenuButtons.ProjectBudget, render: () =&amp;gt; { return ( &amp;lt;React.Fragment&amp;gt; &amp;lt;ProjectBudgetButton key={BizFormMenuButtons.ProjectBudget} /&amp;gt; &amp;lt;/React.Fragment&amp;gt; ); }, }; }; 其中的React组件需要自己实现，主要是一个Button组件。要注意模块启用、权限。
声明按钮 #  有了id和creator函数，就可以声明按钮了。 在 apps/link/src/solutions/biz-form/page/menu-buttons/index.tsx 文件中声明了所有menu按钮的Creator函数。你新创建的按钮也需要在这里声明。
export const buildInMenus = { [BizFormMenuButtons.SourcePicking]: SourcePickCreator, [BizFormMenuButtons.ImportConsumeItem]: ImportConsumeItemCreator, } 声明类型 #  相同类型的按钮会放到同一分组。 在 apps/link/src/solutions/biz-form/page/declare.</description>
    </item>
    
    <item>
      <title>新建开发用租户</title>
      <link>https://zxp-77hub.github.io/docs/other/%E6%96%B0%E5%BB%BA%E7%A7%9F%E6%88%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/other/%E6%96%B0%E5%BB%BA%E7%A7%9F%E6%88%B7/</guid>
      <description>创建新的租户（账号）的方法如下。
  进入运维平台（如果没账号找运维开一个），http://ops.q7link.com:8080/，找到创建租户。   选择环境，手机号搞一个能记住的，其他随便填。然后确定   大改一分钟后刷新页面，看是不是成功了。   成功以后，进入系统，用刚刚的手机号登录，密码是123456，会提示密码简单需要重置。
  重置的话，需要手机号接收验证码。验证码可以通过gql查到。gql地址。需要把下面链接中的IP地址替换成你的环境对应的（见下一步）。
 http://172.31.50.170:9999/graphiql/index.html?query=%7B%0A%20%20VerificationCode(criteriaStr%3A%22verifyIdFlag%20in%20(%2713344445555%27)%20and%20to_char(expiredTime%2C%20%27yyyymmddhh24miss%27)%20%3E%3D%20to_char(CURRENT_TIMESTAMP%2C%20%27yyyymmddhh24miss%27)%20and%20isUsed%20%3D%20%27false%27%22)%7B%0A%20%20%20%20code%0A%20%20%20%20expiredTime%0A%20%20%20%20verifyIdFlag%0A%20%20%7D%0A%7D    这里。找到你的环境，环境会有两个IP，看哪个IP有9999这个服务，把对应的IP放到上面的链接中。   在gql中替换掉你的手机号，就可以查到验证码了。然后重置密码，进入系统就可以了。
  </description>
    </item>
    
    <item>
      <title>脱离form对entity进行crud</title>
      <link>https://zxp-77hub.github.io/docs/common/entitycrud/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/entitycrud/</guid>
      <description>有时我们需要新增、修改、删除一条entity的数据。但是这个entity又没有开发对应的form，无法通过表单来完成。这时就要用到EntityCRUDHelper了
import { EntityCRUDHelper } from &amp;#39;@root/solutions/entity-crud&amp;#39;; EntityCRUDHelper.getInstance().update(EN_BudgetAccountDocImport, data) EntityCRUDHelper提供了create/update/delete等几个方法，可以直接基于entity进行crud操作。
   方法 参数 描述     create entityName, data 创建一条记录   update entityName, data 修改一条记录    注意事项 #  entity不能是子表。子表必须通过主表创建。</description>
    </item>
    
  </channel>
</rss>
