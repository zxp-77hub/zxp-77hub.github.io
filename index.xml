<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>菜鸟集市</title>
    <link>https://zxp-77hub.github.io/</link>
    <description>Recent content on 菜鸟集市</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 18 Oct 2021 10:28:35 +0800</lastBuildDate><atom:link href="https://zxp-77hub.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>初入新手村</title>
      <link>https://zxp-77hub.github.io/docs/base/%E5%88%9D%E5%85%A5%E6%96%B0%E6%89%8B%E6%9D%91/</link>
      <pubDate>Tue, 06 Apr 2021 11:44:40 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/base/%E5%88%9D%E5%85%A5%E6%96%B0%E6%89%8B%E6%9D%91/</guid>
      <description>一、VPN #   申请vpn    等陈欢（欢姐）把vpn的证书发过来。
  安装openvpn，应用证书。
  二、安装环境 #  注意事项：
 go环境的目录结构，GOROOT/src/ metadata项目的名字，git仓库名和本地文件名不一样 go的证书  </description>
    </item>
    
    <item>
      <title>GQL</title>
      <link>https://zxp-77hub.github.io/docs/common/gql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/gql/</guid>
      <description>普通的gql #  最简单的，直接查一个对象（表）的全部数据
{ BudgetAccount{ id name accountType { id name } } } 加一点查询条件
{ BudgetAccount(criteriaStr:&amp;quot;name in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)&amp;quot;){ id name accountType { id name } } } 这个会查到name为1、2、3的多条数据
常用的 gql 查询语句 #  1. 查看某种业务对象的实体名 #  // 例如出入库业务 ObjectType(criteriaStr: &amp;quot;appName=&#39;inventory&#39;&amp;quot;) { id title } 2. 查询预制列表组 #  // 例如公告列表组 QueryDefinitionGroup(criteriaStr:&amp;quot;objectType=&#39;Notice&#39;&amp;quot;){ id objectType title } 3. 预制列表方案 #  // 例如公告列表方案 QueryListDefinition(criteriaStr:&amp;quot;objectType=&#39;Notice&#39;&amp;quot;){ id objectType title } 高级的gql #  上面只能查到一个表的数据及其关联的外键，子表的数据。下面来搞一个子查询。</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>https://zxp-77hub.github.io/posts/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/posts/creating-a-new-theme/</guid>
      <description>Introduction #  This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&#39;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&#39;t cover using CSS to style your theme.
We&#39;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Jekyll</title>
      <link>https://zxp-77hub.github.io/posts/migrate-from-jekyll/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/posts/migrate-from-jekyll/</guid>
      <description>Move static content to static #  Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png  should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png  Additionally, you&#39;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description>
    </item>
    
    <item>
      <title>模型、entity与元数据</title>
      <link>https://zxp-77hub.github.io/docs/base/entity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/base/entity/</guid>
      <description>模型 #  我们系统的后端是领域模型驱动的。比如下图是预算编制方案的模型，其中包含了很多实体(entity)(蓝色的)。 entity #  一个entity就是一个对象，可以通过模型看到各个属性的名字和类型，以及entity之间的关系。
我们前端的工作就是为entity制作表单和列表，来创建entity的实例或展示entity的信息。
元数据 #  前端的元数据主要是对entity的描述。entity的名字、entity的属性名、属性类型等等。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/base/%E9%A2%84%E7%BD%AE%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/base/%E9%A2%84%E7%BD%AE%E6%95%B0%E6%8D%AE/</guid>
      <description>什么是预置数据 #  预置数据可以理解为软件的出厂自带数据，当用户第一次拿到系统时，就存在于系统中的数据。
在预置数据的基础上，用户可以对它们进行修改，也可以添加自己的数据。我们把修改和添加的数据叫做用户数据。
系统中有很多种预置数据。
比如，菜单、查询方案、列表方案
用户可以自己新加几个菜单选项。可以修改查询方案中的字段。可以修改列表方案中显示的列、显示的宽度。等等
预置数据与开发的关系 #  通常，预置数据都会在需求中提到，由产品提供。有些预置数据是后端直接放到数据库里的，前端通过gql取。还有一些是前端在前端开发包里面配置的，这就涉及到了查询方案、列表方案、参照、全局搜索、移动端模板等场景。
将预置数据预置到系统中 #  开发预置的数据是在当前租户的或登录租户的。系统的其他租户是没有这份预置数据的。所以我们需要有一个将预置数据预置到系统中的操作。
 记录一下自己预置了什么（表单、老列表、多列表） 把需要预置的数据的信息整理好，发给曾天保同学。其中几个信息如何获取会在下面介绍。  预置表单 环境: release 后端分支: release 预置租户: PSE5KP504EN000F 改了 Project 预置老列表 环境: test 后端分支: feature-budget-iteration-3rd 预置租户: A24SJR50KMK001E 改了 ProjectMemberView 预置多列表 环境: release 后端分支: release 登录租户id: NSKDNT50NVS002J 多列表方案名称: Project_list 预置租户id：在ops的环境信息中，各个环境都会有预置租户id 登录租户id：打开系统，打开开发者工具network，随便选一个请求，其中header中改回有一个租户id，这就是登陆租户id。 </description>
    </item>
    
    <item>
      <title>什么是BizForm</title>
      <link>https://zxp-77hub.github.io/docs/form/what-is-bizform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form/what-is-bizform/</guid>
      <description>Biz是业务的意思，Form是表单的意思，两个词组合起来就是业务表单。业务泛指我们系统要处理的各种业务，比如项目、报销、合同等等。表单比较常见，就是展示或者收集各种信息的页面。这些页面是由前端框架中的BizForm类实现的。
先看一下我们系统中的表单长什么样。
这是展示了一个编辑态和一个查看态。 这里只简单的看一个样子，其他文档会介绍更加详细的、各个状态、各个部分的内容。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E7%A9%BF%E9%80%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E7%A9%BF%E9%80%8F/</guid>
      <description>穿透 #  我比较喜欢叫它超链接，就是点击列表上的单元格会跳到其他页面的功能。
在这里展示了两种需求：
 会跳到当前单据类型（项目计划）的单据详情页 会跳到其他单据类型（项目）的单据详情页。  代码实现 #    使用rowActionController.makeRowEditAction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class BudgetModelList extends QueryListPagePresenter { { protected getListOption(): IListOption { const listOption = super.getListOption(); return merge(listOption, { gridOption: { actionColumnOption: { visibleSize: 3, }, columnResolver: columnDefs =&amp;gt; { this.</description>
    </item>
    
    <item>
      <title>BizForm的组成部分</title>
      <link>https://zxp-77hub.github.io/docs/form/%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form/%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</guid>
      <description>表单会有不同的状态。
创建和修改时，表单是可以填写内容的，我们称之为编辑态。
查看、审批时，不能编辑内容，只能看，我们称之为查看态。
查看态 #   表单状态 异步任务异常 menu-buttons rang-walk 主表 审批流 子表 ？不知道  </description>
    </item>
    
    <item>
      <title>规则验证</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/%E8%A7%84%E5%88%99%E9%AA%8C%E8%AF%81/</link>
      <pubDate>Mon, 18 Oct 2021 10:28:35 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/%E8%A7%84%E5%88%99%E9%AA%8C%E8%AF%81/</guid>
      <description>验证规则及调试 #   在规则保存成功后，就可以到对应的方案中进行规则验证。
 确认规则被加载 #  1.表单 #   在 bizForm/init 接口中，可以通过 response 是否返回了规则，来验证 规则是否被加载。
 注意❗，目前表单规则中，会返回三部分内容：
 2019年底，在 go 上使用 BizFormRuleManager。AddXXXControl 的规则，id前缀为 &amp;quot;Old-{RuleName}&amp;quot;  2020年底，使用第一版规则工具录入的规则，id前缀为 &amp;quot;{RuleName}-&amp;quot;  使用 ECA Rules 录入的全新规则，id 没有前缀  其中，我们通过配置工具录入的规则，是没有任何前缀的。同时，在多组织后，我们会逐步迁移老代码的规则，敬请各位期待 🤪
调试 #   现阶段，可以通过断点的方式进行调试，目前我们正在推动执行过程数据收集，后续可以根据数据进行问题排查。
 所以规则的运行时代码，都在这里，根据规则名称就可以找到对应的执行代码。所有规则的运行时代码，都会实现 IBizRuleActions 这个接口
/** * @link http://gitlab.q7link.com/front/platform/common-solution/-/blob/feature-multi-org2/src/eca/actions/declare.ts */ export interface IBizRuleActions&amp;lt;T = any&amp;gt; { readonly name: string; schema: JSONSchema7; schemaDefs?: Record&amp;lt;string, JSONSchema7&amp;gt; getExpression?(param: T): RuleFieldItem[] execute(ctx: IRuleActionContext, params: T); } </description>
    </item>
    
    <item>
      <title>基础相关</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Fri, 15 Oct 2021 17:06:04 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/</guid>
      <description>表达式 #   针对每个规则，都实现了表达式
 变量表达式 #     变量 作用 是否允许业务扩展     $root 根节点 ❌   $current 当前节点 ❌   $parent 父节点 ❌   $context 上下文，由场景方案具体指定有哪些属性，通常不允许业务扩展 ❌   $params 参数，通常业务扩展参数定义在这里 ✅   $fn 表达式函数，允许业务扩展 ✅    节点选择器 #  根节点 $root #   来获取当前规则所绑定的节点的根节点。
 ❗❗❗ 注意，不同规则可以绑定在不同节点上，但它们根节点因该相同
详细文档请参考 http://front.q7link.com:3000/docs/biz-rules/docs/eca-rules/get-started/using-expr/using-reference
上下文 $context #   上下文通常指的是在一个技术方案中，由技术方案本身提供的上下文变量，不支持业务扩展。</description>
    </item>
    
    <item>
      <title>ReactiveFieldValidator</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldvalidator/</link>
      <pubDate>Thu, 14 Oct 2021 14:17:38 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldvalidator/</guid>
      <description>ReactiveFieldValidator #   创建一个响应式的字段状态，会根据条件实时添加或删除对应 Validator
 type IReactiveFieldValidatorItem = struct { /** Validator 名称 */ Name string `json:&amp;#34;name&amp;#34;` /** 验证参数 */ Params map[string]interface{} `json:&amp;#34;params&amp;#34;` /** 是否是结构化的 默认是false 如果是false 则 按照实例进行验证 也就是验证加载FormField 实例 如果结构化为true 会剔除实例的影响 直接用logicPath 新增验证 这样的话 就会对当前字表的某一列都有效 */ IsStruct bool `json:&amp;#34;isStruct&amp;#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:&amp;#34;when,omitempty&amp;#34;` /** 是否立即执行 默认值：false */ FireImmediately bool `json:&amp;#34;fireImmediately&amp;#34;` } type IReactiveFieldValidatorParams = struct { /** 目标字段 */ Field string `json:&amp;#34;field&amp;#34;` /** 校验器定义 */ Effect *IReactiveFieldValidatorItem `json:&amp;#34;effect,omitempty&amp;#34;` Effects []*IReactiveFieldValidatorItem `json:&amp;#34;effects,omitempty&amp;#34;` } </description>
    </item>
    
    <item>
      <title>ReactiveFieldComponentProps</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldcomponentprops/</link>
      <pubDate>Thu, 14 Oct 2021 14:16:59 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldcomponentprops/</guid>
      <description>ReactiveFieldComponentProps #   创建一个响应式的透传UI组件Props动作，会自动根据依赖数据实时计算新的 props 结果，并添加到目标字段对应的 UI 组件上
 type IReactiveFieldComponentPropsItem = struct { Props map[string]interface{} `json:&amp;#34;props,omitempty&amp;#34;` IsDestruct bool `json:&amp;#34;isDestruct&amp;#34;` When string `json:&amp;#34;when,omitempty&amp;#34;` FireImmediately bool `json:&amp;#34;fireImmediately,omitempty&amp;#34;` } type IReactiveFieldComponentProps = struct { Field string `json:&amp;#34;field&amp;#34;` Effect *IReactiveFieldComponentPropsItem `json:&amp;#34;effect,omitempty&amp;#34;` Effects []*IReactiveFieldComponentPropsItem `json:&amp;#34;effects,omitempty&amp;#34;` } </description>
    </item>
    
    <item>
      <title>Assignment</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/assignment/</link>
      <pubDate>Thu, 14 Oct 2021 14:16:26 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/assignment/</guid>
      <description>Assignment #   给目标字段进行赋值
 type IAssignmentParams struct { /** * 被赋值字段 */ Field string `json:&amp;#34;field&amp;#34;` /** * 赋值结果，支持表达式 */ Expr string `json:&amp;#34;expr&amp;#34;` } 示例 #  1. 仓库子表初始化默认值 #  { &amp;#34;id&amp;#34;: &amp;#34;d4f0a045-f3c2-4b59-be9d-279edfe08184&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;表体初始化默认值&amp;#34;, &amp;#34;reference&amp;#34;: &amp;#34;miscReceiptItems&amp;#34;, &amp;#34;condition&amp;#34;: { &amp;#34;if&amp;#34;: &amp;#34;$current.editFlag === &amp;#39;add&amp;#39; &amp;amp;&amp;amp; $current.srcObject === undefined&amp;#34; }, &amp;#34;actions&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Assignment&amp;#34;, &amp;#34;params&amp;#34;: { &amp;#34;expr&amp;#34;: &amp;#34;$root.warehouse&amp;#34;, &amp;#34;field&amp;#34;: &amp;#34;warehouse&amp;#34; } } ] } </description>
    </item>
    
    <item>
      <title>FieldValidatorRelations</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/fieldvalidatorrelations/</link>
      <pubDate>Thu, 14 Oct 2021 14:15:46 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/fieldvalidatorrelations/</guid>
      <description>FieldValidatorRelations #   校验规则的字段间关系描述
 type IFieldValidatorRelationsItem = struct { /** * 目标字段 */ Source string `json:&amp;#34;source&amp;#34;` /** * 校验字段 */ Targets []string `json:&amp;#34;targets&amp;#34;` /** * 是否双向影响 * 默认值：false */ Bidirectional bool `json:&amp;#34;bidirectional&amp;#34;` } type IFieldValidatorRelations = struct { Relations []IFieldValidatorRelationsItem `json:&amp;#34;relations&amp;#34;` } 示例 #  1. #  { &amp;#34;name&amp;#34;: &amp;#34;FieldValidatorRelations&amp;#34;, &amp;#34;params&amp;#34;: { &amp;#34;relations&amp;#34;: [ { &amp;#34;bidirectional&amp;#34;: true, &amp;#34;source&amp;#34;: &amp;#34;businessDate&amp;#34;, &amp;#34;targets&amp;#34;: [ &amp;#34;startUsedDate&amp;#34; ] } ] } } </description>
    </item>
    
    <item>
      <title>ReactiveAssignment</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/reactiveassignment/</link>
      <pubDate>Thu, 14 Oct 2021 14:15:05 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/reactiveassignment/</guid>
      <description>ReactiveAssignment #   创建一个响应式的赋值动作，会根据规则中的依赖字段返回实时的新计算结果，并赋给目标字段
 type IReactiveAssignmentEffect = struct { /** 取值表达式 */ Expr string `json:&amp;#34;expr&amp;#34;` /** 当目标字段有值时，根据 overrideExpr 的结果来判断是否需要覆盖 默认值：false */ Override bool `json:&amp;#34;override&amp;#34;` /** 当取值表达式为空时，根据 autoClear 的结果判断是否同步清空 默认值：false */ AutoClear bool `json:&amp;#34;autoClear&amp;#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:&amp;#34;when,omitempty&amp;#34;` /** 是否立即生效 默认值：false */ FireImmediately bool `json:&amp;#34;fireImmediately&amp;#34;` } type IReactiveAssignmentEffectV2 = struct { /** 取值表达式 */ Expr string `json:&amp;#34;expr&amp;#34;` /** 当目标字段有值时，根据 overrideExpr 的结果来判断是否需要覆盖 默认值：false */ Override string `json:&amp;#34;override&amp;#34;` /** 当取值表达式为空时，根据 autoClear 的结果判断是否同步清空 默认值：false */ AutoClear string `json:&amp;#34;autoClear&amp;#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:&amp;#34;when,omitempty&amp;#34;` /** 是否立即生效 默认值：false */ FireImmediately string `json:&amp;#34;fireImmediately&amp;#34;` } type IReactiveAssignmentParams = struct { /** 目标字段 */ Field string `json:&amp;#34;field&amp;#34;` /** 赋值来源 */ Effect *IReactiveAssignmentEffect `json:&amp;#34;effect,omitempty&amp;#34;` Effects []*IReactiveAssignmentEffect `json:&amp;#34;effects,omitempty&amp;#34;` } type IReactiveAssignmentParamsV2 = struct { /** 目标字段 */ Field string `json:&amp;#34;field&amp;#34;` /** 赋值来源 */ Effect *IReactiveAssignmentEffectV2 `json:&amp;#34;effect,omitempty&amp;#34;` Effects []*IReactiveAssignmentEffectV2 `json:&amp;#34;effects,omitempty&amp;#34;` } 示例 #  1.</description>
    </item>
    
    <item>
      <title>头体字段值同步</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/%E5%A4%B4%E4%BD%93%E5%AD%97%E6%AE%B5%E5%80%BC%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Wed, 13 Oct 2021 17:47:15 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/%E5%A4%B4%E4%BD%93%E5%AD%97%E6%AE%B5%E5%80%BC%E5%90%8C%E6%AD%A5/</guid>
      <description>ReactiveMasterToTables #   创建一个响应式的表头同步数据到表体，会根据表头的表达式结果，实时进行同步
 /** * 子表设置 */ type IReactiveMasterToTablesTarget = struct { /** * 子表字段名 */ DataTable string `json:&amp;#34;dataTable&amp;#34;` /** * 同步的列字段名 */ Field string `json:&amp;#34;field&amp;#34;` /** * 数据过滤表达式，类似之前的视图，只有在满足表达式条件下的数据行，会被同步数据 * expr =&amp;gt; boolean, defaultWhen =&amp;gt; ignore disabled | readonly */ ViewName string `json:&amp;#34;viewName,omitempty&amp;#34;` /** * 数据过滤表达式，类似之前的视图，只有在满足表达式条件下的数据行，会被同步数据 * expr =&amp;gt; boolean, defaultWhen =&amp;gt; ignore disabled | readonly */ When string `json:&amp;#34;when,omitempty&amp;#34;` /** * force update all */ Always string `json:&amp;#34;always,omitempty&amp;#34;` } /** * 表头字段同步到子表上 */ type IReactiveMasterToTablesParams = struct { /** * 表头字段表达式 */ SourceValue string `json:&amp;#34;sourceValue&amp;#34;` /** * 子表设置 */ Target *IReactiveMasterToTablesTarget `json:&amp;#34;target,omitempty&amp;#34;` /** * 多子表设置（推荐） */ Targets []*IReactiveMasterToTablesTarget `json:&amp;#34;targets,omitempty&amp;#34;` } 字段值</description>
    </item>
    
    <item>
      <title>ReactiveFieldStatus</title>
      <link>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldstatus/</link>
      <pubDate>Thu, 30 Sep 2021 10:39:28 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/eca-rules/reactivefieldstatus/</guid>
      <description>ReactiveFieldStatus #   创建一个响应式的字段状态，会根据依赖数据实时返回新状态，并添加到目标字段上
 type IReactiveFieldStatusEffect = struct { /** 状态名称 目前支持：Readonly、Required */ Status string `json:&amp;#34;status&amp;#34;` /** 状态值表达式 */ Expr interface{} `json:&amp;#34;expr&amp;#34;` /** 当 when = true 时，才会执行规则 默认值：true */ When string `json:&amp;#34;when,omitempty&amp;#34;` /** 是否立即生效 默认值：false */ FireImmediately bool `json:&amp;#34;fireImmediately&amp;#34;` } type IReactiveFieldStatusParams = struct { /** 目标字段 */ Field string `json:&amp;#34;field&amp;#34;` /** 状态设置 */ Effect *IReactiveFieldStatusEffect `json:&amp;#34;effect,omitempty&amp;#34;` Effects []*IReactiveFieldStatusEffect `json:&amp;#34;effects,omitempty&amp;#34;` } 示例 #  1. 当创建组织为空时，startPeriod 字段禁用 #  { &amp;quot;name&amp;quot;: &amp;quot;ReactiveFieldStatus&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;描述处理的场景&amp;quot;, &amp;quot;params&amp;quot;: { &amp;quot;effect&amp;quot;: { &amp;quot;expr&amp;quot;: &amp;quot;true&amp;quot;, // &amp;quot;fireImmediately&amp;quot;: true, // 是否立即执行 &amp;quot;status&amp;quot;: &amp;quot;Readonly&amp;quot;, // Readonly，Required &amp;quot;when&amp;quot;: &amp;quot;$root.</description>
    </item>
    
    <item>
      <title>Notice</title>
      <link>https://zxp-77hub.github.io/docs/component/notice/</link>
      <pubDate>Thu, 19 Aug 2021 10:04:57 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/component/notice/</guid>
      <description></description>
    </item>
    
    <item>
      <title>视图</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Thu, 08 Jul 2021 17:02:03 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E8%A7%86%E5%9B%BE/</guid>
      <description>适用于表单。
 主表presenter的getDataOptions  dynamicViews: { [F_BudgetAccount_refDocMappings(子表名字)]: &amp;#39;viewName(视图名字)&amp;#39;, }, 子表presenter  // 视图的数据 private viewData = observable.array([]); // 查看态 onFormViewed(form: EntityForm&amp;lt;any&amp;gt;, disposers: IDisposer[]) { this.addView(disposers) } // 编辑态 onFormCreated(form: EntityForm&amp;lt;any&amp;gt;, disposers: IDisposer[]) { this.addView(disposers) } addView = (disposers) =&amp;gt; { this.formPresenter.formController.addDynamicView( this.logicPath, &amp;#39;viewName&amp;#39;, this.viewData, ) disposers.push( // 监听子表的数据变化  reaction( () =&amp;gt; { return this.form.select(this.logicPath).value.slice(); }, this.updateData, { fireImmediately: true }, ), ); } // 将子表数据进行处理后赋值给视图数据 updateData = () =&amp;gt; { const data = this.</description>
    </item>
    
    <item>
      <title>坑</title>
      <link>https://zxp-77hub.github.io/docs/multi-org/%E5%9D%91/</link>
      <pubDate>Mon, 28 Jun 2021 14:16:16 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/multi-org/%E5%9D%91/</guid>
      <description>列表的路由不能传path参数 #  文档里说要用renderDocumentListRouters这个方法生成路由，但是不能传path参数指定url。 它的内部用renderDocumentList和renderMultiOrgDocumentList2个方法生成了一个普通列表路由，一个多组织列表的路由。
为了解决传path的问题，可以像下面这样写代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  { ...renderDocumentList({ title: &amp;#39;编制方案设置&amp;#39;, entityName: EN_BudgetModel, groupName: `${EN_BudgetModel}_list`, createPresenter: async options =&amp;gt; { const { BudgetModelList } = await import( &amp;#39;@main/screens/projects/budget/budget-model/list/BudgetModelList&amp;#39; ); return new BudgetModelList({ ...options }); }, }), refreshWhenParamsChanged: true, path: appRouterHashManager.</description>
    </item>
    
    <item>
      <title>外键穿透的自定义点击事件</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E5%A4%96%E9%94%AE%E7%A9%BF%E9%80%8F%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Thu, 06 May 2021 10:59:01 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E5%A4%96%E9%94%AE%E7%A9%BF%E9%80%8F%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  protected onInitialized(formPresenter) { formPresenter.getBean(BeanNames.EventController).on(InternalEvent.onCancel, this.cancel); const isTemplateBill = this.isTemplateBill; if (isTemplateBill) { // 修改外键（项目project）的onClick的穿透的行为。当是计划模板时，穿透到项目模板。  const masterRenderController = this.formPresenter.getBean(BeanNames.MasterRendererController); const billTypeId = this.getBillTypeId(); const options: ForeignKeyLinkRenderOption = { onClick(params: ForeignKeyLinkClickParams) {  if (params.entityName === EN_Project){ const hash = appRouterHashManager.generateHash(&amp;#39;ProjectTemplate&amp;#39;, PageModeEnum.Form as any, { mode: BizFormModeEnum.</description>
    </item>
    
    <item>
      <title>场景值reaction</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E5%9C%BA%E6%99%AF%E5%80%BCreaction/</link>
      <pubDate>Mon, 26 Apr 2021 17:49:17 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E5%9C%BA%E6%99%AF%E5%80%BCreaction/</guid>
      <description>如果表单的A字段设置了reaction监听。当修改A的value的时候，对应的reaction都会触发。如果希望不触发reaction，就要用到下面的场景值reaction
// 根据场景值忽略执行的reaction const reactionOmit = this.bizFormPresenter.api.reactionOmitCreator( BizFormScenarios.SourcePicking, ); // 使用reactionOmit监听 disposers.push( reactionOmit( () =&amp;gt; form.select(&amp;#39;F_TimesheetLine_orgRoleType&amp;#39;).value, value =&amp;gt; { } ) ) // 使用reactionOmit对应的场景值赋值，就不会触发reaction this.bizFormPresenter.api.runInScenarios(BizFormScenarios.SourcePicking, () =&amp;gt; { rowField.select(F_TimesheetLine_orgRoleType).value = { id: EN_Department, title: &amp;#39;部门&amp;#39;, name: EN_Department, }; }) </description>
    </item>
    
    <item>
      <title>表头字段自定义渲染</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E8%A1%A8%E5%A4%B4%E5%AD%97%E6%AE%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Mon, 26 Apr 2021 15:58:49 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E8%A1%A8%E5%A4%B4%E5%AD%97%E6%AE%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93/</guid>
      <description>表单中配置masterRender可以实现表头字段的自定义渲染，但是外键字段不能通过masterRender处理。
在MasterRendererController.tsx中有一段代码
const after: IMasterFieldRender[] = [new LinkRender(), new ForeignKeyLinkRender(), new CommonFieldRender()]; 外键字段会走到ForeignKeyLinkRender组件，而masterRender只在CommonFieldRender中才有使用。
protected getDisplayOptions(): DisplayOptions { return { masterRender: { [&amp;#39;project&amp;#39;]: props =&amp;gt; { const LinkDiv = styled.div` height: 100%; display: flex; align-items: center; padding-left: 8px; cursor: pointer; color: var(--primary-500); text-decoration: underline; text-underline-position: under; ` return ( &amp;lt;MSTFormElement label={props.template.title} path={&amp;#39;project&amp;#39;} colspan={1} disableError={true} disabled={true} isRequired={false} labelResolver={value =&amp;gt; value[&amp;#39;project&amp;#39;]} // value 对应的 path={...}中的值 contentRenderer={() =&amp;gt; { const data = props.form.value.project return ( &amp;lt;LinkDiv&amp;gt; &amp;lt;span onClick={async () =&amp;gt; { const hash = appRouterHashManager.</description>
    </item>
    
    <item>
      <title>按钮权限</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90/</link>
      <pubDate>Mon, 26 Apr 2021 15:38:47 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90/</guid>
      <description>多列表方案处理了顶部按钮的权限，但是要在列表方案中指定resourceId
public getQueryListOption(): IQueryListSolutionPresenterOptions { return { ...super.getQueryListOption(), resourceId: &amp;#39;xxxxxxxxxxxxxxx&amp;#39;, }; } </description>
    </item>
    
    <item>
      <title>QueryField</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/queryfield/</link>
      <pubDate>Wed, 14 Apr 2021 18:57:28 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/queryfield/</guid>
      <description>列表数据会查询哪些字段一般是在预置数据里设置的。也可以通过代码控制。
1 2 3 4 5 6 7 8 9 10 11 12 13  export class ProjectConfirmationListListPresenter extends QueryListPagePresenter { getQueryListOption(): IQueryListSolutionPresenterOptions { return { ...super.getQueryListOption(), resourceId: ResourceConstants.Res_ProjectConfirmation, getDynamicQueryFields: () =&amp;gt; { return [&amp;#39;task.project.id&amp;#39;]; }  }; } }   </description>
    </item>
    
    <item>
      <title>行按钮rowAction</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E8%A1%8C%E6%8C%89%E9%92%AErowaction/</link>
      <pubDate>Wed, 14 Apr 2021 18:43:40 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E8%A1%8C%E6%8C%89%E9%92%AErowaction/</guid>
      <description>适用于：多列表
效果图： export class BudgetModelList extends QueryListPagePresenter { // 覆盖父类的方法  getRowActions(rowIndex: number, data: any): IGridAction[] { // 获取公共默认的actions  const actions = this.presenter.listSolutionConnector.rowActionController.makeDefaultRowActions( data, ); if (data &amp;amp;&amp;amp; data.id) { // 加新的按钮  actions.push({ icon: ICON_VIEW, title: &amp;#39;预览&amp;#39;, key: &amp;#39;preview&amp;#39;, onClick: (rowIndex, data) =&amp;gt; this.preview(data), }); } // 还可以对actions数组进行过滤  return actions; } } </description>
    </item>
    
    <item>
      <title>自定义单据</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E6%8D%AE/</link>
      <pubDate>Tue, 13 Apr 2021 21:07:54 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E6%8D%AE/</guid>
      <description>两部分组成：
 创建form form组件  function createForm(): EntityForm { const formScheme = { closeDate: { type: FieldTypeEnum.Timestamp, initState: { label: &amp;#39;关闭日期&amp;#39;, required: false, visible: false, }, }, closedReason: { type: FieldTypeEnum.JsonObject, referType: EN_BizReason, initState: { label: &amp;#39;关闭原因&amp;#39;, required: false, visible: false, }, }, closedReasonExplain: { type: FieldTypeEnum.String, initState: { label: &amp;#39;关闭原因说明&amp;#39;, required: false, visible: false, }, }, }; const formBuilder = new FormBuilder(); Object.entries(formScheme).forEach(([key, value]) =&amp;gt; { formBuilder.appendField(key, makeField(value)); }); return formBuilder.</description>
    </item>
    
    <item>
      <title>选中行</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E9%80%89%E4%B8%AD%E8%A1%8C/</link>
      <pubDate>Tue, 13 Apr 2021 21:06:01 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E9%80%89%E4%B8%AD%E8%A1%8C/</guid>
      <description>适用于：多列表方案
this.presenter.listSolutionConnector.selectionItems </description>
    </item>
    
    <item>
      <title>顶部按钮ToolbarAction</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE/</link>
      <pubDate>Tue, 13 Apr 2021 20:55:08 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE/</guid>
      <description>适用于：多列表方案
效果图： export class ProjectListPagePresenter extends QueryListPagePresenter{ protected commandActionResolver(commandActions: ToolbarAction[]): ToolbarAction[] { // 简单的action  commandActions.unshift({ id: &amp;#39;project-view&amp;#39;, group: ToolbarActionGroup.Group1, action: this.presenter.toolbarConnector.makeCreateButton({ onClick: billTypeId =&amp;gt; { }, }), }); // 复杂的action  commandActions.push(new ProjectMultiCloseAction(this.presenter.listSolutionConnector)) } }  覆盖父类的commandActionResolver方法。向参数commandActions数组中添加ToolbarAction元素即可。 ToolbarAction有两种方式创建。 简单的话，可以用对象字面量创建。 复杂的话，就用一个对象来实现ToolbarAction。参考ProjectMultiCloseAction  </description>
    </item>
    
    <item>
      <title>编辑或显示数字精度</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E7%BC%96%E8%BE%91%E6%88%96%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6/</link>
      <pubDate>Thu, 01 Apr 2021 18:19:56 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E7%BC%96%E8%BE%91%E6%88%96%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6/</guid>
      <description>控制编辑，设置editParams
public getEditOptions(): EditOptions { return { editParams: { [主表字段名]: () =&amp;gt; { return { numericProps: { decimalPlaces: 精度, minimumValue: &amp;#39;0&amp;#39;, } } }, [`子表名.子表字段名`]: () =&amp;gt; { return { numericProps: { decimalPlaces: 精度, minimumValue: &amp;#39;0&amp;#39;, } } }, } } } 控制显示，子表要自定义渲染
getGridOptions(): Optional&amp;lt;AdvanceGridProps&amp;gt; { return { columnResolver: (colDefs: ColDef[]) =&amp;gt; { const daysField = colDefs.find(c =&amp;gt; c.field === F_TimesheetLine_days); if (daysField) { daysField.cellRendererFramework = (params) =&amp;gt; { return React.</description>
    </item>
    
    <item>
      <title>水印</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E6%B0%B4%E5%8D%B0/</link>
      <pubDate>Wed, 31 Mar 2021 16:28:22 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E6%B0%B4%E5%8D%B0/</guid>
      <description>go项目
 trek/services/form-services/middlewares/entities/【实体名】/params.go  // 1. 实体的哪些字段要作为水印 var watermarkFieldNames = []string{ gen_ef.F_Project_billFullStatusObject, gen_ef.F_Project_budgetStatus, } var ( // 2. 	watermarkSettingParams = form_service_middlewares_common.WatermarkSettingMiddlewareCreatorParams{ Items: form_service_middlewares_common.DefaultWatermarkSettingItemsCreator(watermarkFieldNames...), } // 3. 	billCommonRulesParams = form_service_middlewares_common.BillCommonRulesCreatorParams{ WatermarkSettingMiddlewareCreatorParams: &amp;amp;watermarkSettingParams, } ) trek/services/form-services/middlewares/entities/【实体名】/index.go  func GetMiddlewareCreators() []form_context.FormMiddlewareCreator { middlewareCreators := []form_context.FormMiddlewareCreator{ // 1. 	form_service_middlewares_common.BillCommonRulesMiddlewareCreator(billCommonRulesParams), } } </description>
    </item>
    
    <item>
      <title>子表</title>
      <link>https://zxp-77hub.github.io/docs/form/%E5%AD%90%E8%A1%A8/</link>
      <pubDate>Wed, 24 Mar 2021 10:44:07 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form/%E5%AD%90%E8%A1%A8/</guid>
      <description>formPresenter一般都是在路由中初始化的。 业务presenter（都是继承了 EasyBizFormPresenter）的构造器中会调用super， super中会调createItemsPresenters将子表也new出来，让子表保存到 itemsPresenters 中。 可以在业务presenter中遍历 itemsPresenters 通过 itemsPresenter 的 logicPath （子表的path）拿到某个子表对象。</description>
    </item>
    
    <item>
      <title>提示</title>
      <link>https://zxp-77hub.github.io/docs/component/%E6%8F%90%E7%A4%BA/</link>
      <pubDate>Mon, 22 Mar 2021 17:37:07 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/component/%E6%8F%90%E7%A4%BA/</guid>
      <description>import { showError, showInfo, showSuccess } from &amp;#39;@root/common/toaster&amp;#39;; showSuccess(&amp;#39;text&amp;#39;) 自适应内容高度的提示
// apps/link/src/main/screens/projects/budget/budget-account/presenter/budget-account-form-presenter/helper.tsx  AlphaWarning( &amp;#39;text&amp;#39;, () =&amp;gt; {}, () =&amp;gt; {}, ); </description>
    </item>
    
    <item>
      <title>Value</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/value/</link>
      <pubDate>Wed, 17 Mar 2021 17:01:44 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/value/</guid>
      <description>Presenter.api.formController.form.select(&#39;modelSubtables/0/dimensions/2&#39;).value
Presenter.api.formController.form.getSubmitValue()</description>
    </item>
    
    <item>
      <title>币种精度</title>
      <link>https://zxp-77hub.github.io/docs/common/%E5%B8%81%E7%A7%8D%E7%B2%BE%E5%BA%A6/</link>
      <pubDate>Wed, 17 Mar 2021 11:53:41 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E5%B8%81%E7%A7%8D%E7%B2%BE%E5%BA%A6/</guid>
      <description>import { store } from &amp;#39;@models&amp;#39;; // 表单中(EasyBizFormPresenter) this.localCurrency.precision // 不在EasyBizFormPresenter中 store.exchangeDefManager.getLocalCurrency().precision </description>
    </item>
    
    <item>
      <title>全貌统计加指标</title>
      <link>https://zxp-77hub.github.io/docs/common/%E5%85%A8%E8%B2%8C%E7%BB%9F%E8%AE%A1%E5%8A%A0%E6%8C%87%E6%A0%87/</link>
      <pubDate>Tue, 16 Mar 2021 11:27:50 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E5%85%A8%E8%B2%8C%E7%BB%9F%E8%AE%A1%E5%8A%A0%E6%8C%87%E6%A0%87/</guid>
      <description>https://shimo.im/sheets/16q8MDar7Ktv0mk7/cayv7，所有的指标会在这个文档里说明。其中【指标编码】是下文中提到的 MeasureId 。
需要现在go上配置好指标，然后在前端中获取指标并进行设置。
go #   trek/services/dashboard/config/project-overview.go addProjectStatisticsConfig函数 addConfig  // 多值指标 addConfig(&amp;amp;dashboard.EvaluateCardConfig{ Id: &amp;#34;projectTimeStatisticCost&amp;#34;, Title: &amp;#34;工时成本&amp;#34;, Icon: &amp;#34;icongongshi1&amp;#34;, ViewType: dashboard.CardViewType_MultiValue, ValueConfig: []dashboard.EvaluateValueConfig{ { Id: &amp;#34;workingTimeCost&amp;#34;, Icon: &amp;#34;iconzonggongshi&amp;#34;, Title: &amp;#34;总工时成本&amp;#34;, MeasureId: &amp;#34;workingTimeCost&amp;#34;, Unit: dashboard.CardViewUnit_TenThounsand, ClassName: &amp;#34;color1&amp;#34;, SupportPenetrate: true, IsAmount: true, ValuePeriodType: dashboard.MeasurePeriodValueTypeOccurs, }, } }) // 单值指标 addConfig(&amp;amp;dashboard.EvaluateCardConfig{ Id: &amp;#34;workingTimeCost&amp;#34;, Title: &amp;#34;总工时成本&amp;#34;, Icon: &amp;#34;&amp;#34;, ViewType: dashboard.CardViewType_SingleValue, ValueConfig: dashboard.EvaluateValueConfig{ Id: &amp;#34;count&amp;#34;, Icon: &amp;#34;iconzonggongshi&amp;#34;, Title: &amp;#34;总工时成本&amp;#34;, MeasureId: &amp;#34;workingTimeCost&amp;#34;, Unit: dashboard.CardViewUnit_TenThounsand, IsAmount: true, ClassName: &amp;#34;color1&amp;#34;, SupportPenetrate: true, ValuePeriodType: dashboard.</description>
    </item>
    
    <item>
      <title>模块启用</title>
      <link>https://zxp-77hub.github.io/docs/common/%E6%A8%A1%E5%9D%97%E5%90%AF%E7%94%A8/</link>
      <pubDate>Thu, 11 Mar 2021 11:01:34 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E6%A8%A1%E5%9D%97%E5%90%AF%E7%94%A8/</guid>
      <description>go #  go项目，获取功能权限是否开启
b := ctx.GetBusinessModuleById(gen_ec.EC_BusinessModule_BusinessModule_budget) // b.IsEnabled 前端 #  import { store } from &amp;#39;@models&amp;#39;; class A { b() { const contractModel = store.moduleInitManager.getModuleById(&amp;#39;BusinessModule_contract&amp;#39;); if ( !contractModel || !contractModel.isEnabled ) { // ...  } } } </description>
    </item>
    
    <item>
      <title>Gen</title>
      <link>https://zxp-77hub.github.io/docs/common/gen/</link>
      <pubDate>Wed, 10 Mar 2021 17:41:36 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/gen/</guid>
      <description> 后端实体构建发版后，前端和go 要生成相应的 json
 1. go 端 #  进入 script 目录运行
 sh gen.sh 2. 前端 #  直接运行 rush gen 环境
问题 #   某些变量在本地跑完gen后不见了  可能是后端该了某些属性的名字，但是0租户没有同步。    </description>
    </item>
    
    <item>
      <title>AllPaths</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/allpaths/</link>
      <pubDate>Mon, 08 Mar 2021 15:38:59 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/allpaths/</guid>
      <description>bizFormPresenter.api.formController.entityCRUD.allPaths bizFormPresenter.api.getForm().select(&#39;timesheetLines/0/indvRole&#39;) </description>
    </item>
    
    <item>
      <title>查询项的默认值</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/%E6%9F%A5%E8%AF%A2%E9%A1%B9%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/</link>
      <pubDate>Mon, 01 Mar 2021 14:29:52 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/%E6%9F%A5%E8%AF%A2%E9%A1%B9%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/</guid>
      <description>这里介绍如何为查询项设置默认值。 参看：trek/services/query-list/middlewares/entities/project-schedule/query-default-value.go
主要的代码是这段
func (m *billStatusObjectMiddleware) QueryDefHandler(ctx query_list.QueryListContext, api query_list.QueryDefApi) { schema := api.GetQueryItemSchema(billStatusObjectFieldName) if schema != nil { defaultVal := map[string]interface{}{ &amp;#34;values&amp;#34;: []defItem{ { Title: &amp;#34;已生效&amp;#34;, Id: &amp;#34;BillStatus.effective&amp;#34;, }, }, } api.SetDefaultValue(billStatusObjectFieldName, defaultVal) schema.OperatorId = gen_enums.ENUM_CriteriaOperator_in schema.Operator = ctx.GetContext().GetMetadata().GetEnumValue(gen_enums.ENUM_CriteriaOperator, gen_enums.ENUM_CriteriaOperator_in) } } </description>
    </item>
    
    <item>
      <title>单据状态</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E5%8D%95%E6%8D%AE%E7%8A%B6%E6%80%81/</link>
      <pubDate>Fri, 26 Feb 2021 14:29:44 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E5%8D%95%E6%8D%AE%E7%8A%B6%E6%80%81/</guid>
      <description>export const ENUM_BillStatus = &amp;#34;BillStatus&amp;#34;; // 单据状态 export const ENUM_BillStatus_draft = &amp;#34;BillStatus.draft&amp;#34;; // 未提交 export const ENUM_BillStatus_submitting = &amp;#34;BillStatus.submitting&amp;#34;; // 提交中 export const ENUM_BillStatus_submitted = &amp;#34;BillStatus.submitted&amp;#34;; // 已提交 export const ENUM_BillStatus_approving = &amp;#34;BillStatus.approving&amp;#34;; // 审批中 export const ENUM_BillStatus_effecting = &amp;#34;BillStatus.effecting&amp;#34;; // 生效中 export const ENUM_BillStatus_effective = &amp;#34;BillStatus.effective&amp;#34;; // 已生效 export const ENUM_BillStatus_restarting = &amp;#34;BillStatus.restarting&amp;#34;; // 退回中 export const ENUM_BillStatus_restarted = &amp;#34;BillStatus.restarted&amp;#34;; // 已退回 export const ENUM_BillStatus_recalling = &amp;#34;BillStatus.recalling&amp;#34;; // 撤回中 export const ENUM_BillStatus_recalled = &amp;#34;BillStatus.</description>
    </item>
    
    <item>
      <title>删除行</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/%E5%88%A0%E9%99%A4%E8%A1%8C/</link>
      <pubDate>Mon, 22 Feb 2021 18:20:56 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/%E5%88%A0%E9%99%A4%E8%A1%8C/</guid>
      <description>const refDocMappingsField = this.form.select(F_BudgetAccount_refDocMappings); if (refDocMappingsField.value !== undefined) { let len = refDocMappingsField.value.length; while (len&amp;gt;0){ this.formController.deleteRowByRealIndex( F_BudgetAccount_refDocMappings, len - 1, ); len --; } } </description>
    </item>
    
    <item>
      <title>查询项</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/%E6%9F%A5%E8%AF%A2%E9%A1%B9/</link>
      <pubDate>Tue, 26 Jan 2021 11:05:11 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/%E6%9F%A5%E8%AF%A2%E9%A1%B9/</guid>
      <description>多列表方案中的 getQueryResolverOptions 方法可以用来设置【查询项】
class BudgetPlanBasePresenter extends QueryListPagePresenter { protected getQueryResolverOptions(queryListDef, option): IQueryModelResolverOptions { return { someKey: onModelCreated: (item: QueryItem) =&amp;gt; { item.value } } } } 数据结构
export interface IQueryModelResolverOptions { [key: string]: IQueryModelItemResolverOptions | IQueryModelItemResolverCreator; } export type IQueryModelItemResolverCreator = (options) =&amp;gt; IQueryModelItemResolverOptions; export interface IQueryModelItemResolverOptions&amp;lt;T = any&amp;gt; { // 显示查询方案时，每次都会触发  onModelCreated?: (item: QueryItem) =&amp;gt; void; baseFieldOptionsResovler?: ( item: IQueryCriteria, options: FieldOptions, ) =&amp;gt; MSTFormOptions[&amp;#39;fieldOptions&amp;#39;] | FieldOptions; baseTypeResolver?: (item: IQueryCriteria, type: IType&amp;lt;any, any, any&amp;gt;) =&amp;gt; IType&amp;lt;any, any, any&amp;gt;; itemFieldOptionsResolver?</description>
    </item>
    
    <item>
      <title>AdvanceDialog</title>
      <link>https://zxp-77hub.github.io/docs/component/advancedialog/</link>
      <pubDate>Wed, 20 Jan 2021 19:00:09 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/component/advancedialog/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import { showDialog, requestDialogId, closeDialog } from &amp;#39;@root/common/dialog&amp;#39;; import { AdvanceDialog } from &amp;#39;@components/advance-dialog/AdvanceDialog&amp;#39;; function renderDialog() { const dialogId = requestDialogId();  showDialog(dialogId, (  &amp;lt;AdvanceDialog isOpen title=&amp;#34;催办&amp;#34; buttons={[{ text: &amp;#39;确定&amp;#39;, onClick: () =&amp;gt; {  closeDialog(dialogId) } }]} onClose={() =&amp;gt; {  closeDialog(dialogId) }} &amp;gt; &amp;lt;/AdvanceDialog&amp;gt; )) }   列宽可以通过鼠标拖动</description>
    </item>
    
    <item>
      <title>Refer</title>
      <link>https://zxp-77hub.github.io/docs/component/refer/</link>
      <pubDate>Wed, 13 Jan 2021 11:39:09 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/component/refer/</guid>
      <description>form中设置 #  getEditOptions之editParams #  editParams是定义每个field（也可以设置子表的field）的编辑态的参数。
{ [key: fieldName]: 参数对象 } 参数对象需要根据field具体是什么来行确定，比如field可能是数字、字符串、参照等，对应的渲染组件就是NumberField，ReferField，TextField等，参数对象就是对应的渲染组件的参数。
参数 #  // 高级参照支持多选 enableMultiInsert: true, criteriaStr: criteriaStr, referConfigResolver: referConfig =&amp;gt; { return Object.assign({}, referConfig, { displayField: &#39;code&#39;, }); }, advanceReferProps: { categoryCriteriaStr: , }, queryFields: [], onMultiInsert: ( data: Array&amp;lt;ICustomizedCarryoverProgrammeSubjectSetting&amp;gt;, editRowField: MSTFormField, ) =&amp;gt; { if (Array.isArray(data) &amp;amp;&amp;amp; data.length &amp;gt; 0) { const origin = editRowField.value || []; for (let i = 0, len = data.</description>
    </item>
    
    <item>
      <title>获取业务规则</title>
      <link>https://zxp-77hub.github.io/docs/common/%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99/</link>
      <pubDate>Tue, 05 Jan 2021 17:48:57 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99/</guid>
      <description>方式一 #  class ProjectFormPresenter extends EasyBizFormPresenter&amp;lt;IProject&amp;gt;{ private billTypeRules: Array&amp;lt;IBizProcessFuncUnitSetting&amp;gt; = []; xx() { const businessRules = this.bizFormPresenter.api.getBusinessRules() this.billTypeRules = oc(businessRules).rules([]) } } 方式二 #  import { FuncUnit_Constants } from &amp;#39;@q7/athena-gen/src&amp;#39;; class ProjectPlanButton extends MenuButton { private checkEnableProjectRule = () =&amp;gt; { const enableProject: IBizProcessFuncUnitSetting = this.presenter.api.getBusinessRuleById( FuncUnit_Constants.enableProjectScheduleValidator, ); if (enableProject) { return enableProject.setting; } return; }; } 其中FuncUnit_Constants是根据预置数据生成的，可以问后端你要的业务规则的名字。
业务规则的类型 #  interface IBizProcessFuncUnitSetting { applyTo?: { [key: string]: any } // 应用的对象, 	applyToTypeObject?</description>
    </item>
    
    <item>
      <title>创建form时带默认数据</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/init-form/</link>
      <pubDate>Tue, 05 Jan 2021 11:25:11 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/init-form/</guid>
      <description>场景 #  在新建”项目“时，选择了项目分类后点新建，所选择的分类会出现在表单的”项目分类“中。
 选择分类 点新建  自动填写了“项目分类”   怎么实现 #    在跳转页面时，将需要的参数放入proxyHistory.push的第二个参数passParams中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class ProjectListPagePresenter extends QueryListPagePresenter&amp;lt; IProjectListPagePresenterOption &amp;gt;{ protected commandActionResolver(commandActions: ToolbarAction[]): ToolbarAction[] { commandActions.unshift({ id: &amp;#39;project-view&amp;#39;, group: ToolbarActionGroup.Group1, action: this.presenter.toolbarConnector.makeCreateButton({ onClick: billTypeId =&amp;gt; { const hash = appRouterHashManager.generateHash(EN_Project, PageModeEnum.</description>
    </item>
    
    <item>
      <title>TabList</title>
      <link>https://zxp-77hub.github.io/docs/component/tablist/</link>
      <pubDate>Mon, 04 Jan 2021 23:57:09 +0800</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/component/tablist/</guid>
      <description>&amp;lt;TabList focusIndex={this.focusIndex} onTabChange={index =&amp;gt; { }} &amp;gt; &amp;lt;Tab key={1} title=&amp;#34;编码方案&amp;#34; /&amp;gt; &amp;lt;Tab key={2} title=&amp;#34;对照码&amp;#34; /&amp;gt; &amp;lt;/TabList&amp;gt; </description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>https://zxp-77hub.github.io/posts/goisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/posts/goisforlovers/</guid>
      <description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>https://zxp-77hub.github.io/posts/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/posts/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo #  Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs #  Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/component/grid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/component/grid/</guid>
      <description>grid #  grid是前端解决子表和列表的方案，对应的组件是AdvanceGird。
editOptions #  editOptions下面的editParams会传给单元格的渲染组件
表单 #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/form-guide/menu-button/%E8%81%94%E6%9F%A5%E6%8C%89%E9%92%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/menu-button/%E8%81%94%E6%9F%A5%E6%8C%89%E9%92%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88/</guid>
      <description>a #  </description>
    </item>
    
    <item>
      <title>MSTForm-Form状态管理</title>
      <link>https://zxp-77hub.github.io/docs/form/mstform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form/mstform/</guid>
      <description>随着应用复杂度提升，现在不可避免的就是数据状态管理，现在有很多流行框架，redux、mobx、rxjs等等。不同的解决方案在不同场景下会有明显的优劣势，而我们要做的，就是根据场景来选择合适的方案。
首先，在我们的应用中，我们聚焦到有大量用户输入的表单场景下，我们有以下硬性需求：
 维护用户录入的字段值； 不同的字段之间有联动关系，修改一个会导致另外一个发生改变； 不同的字段之间，状态会相互影响，修改一个会导致另外一个不可编辑； 表单要支持校验；  由这些需求可以看到，在这种场景下，数据驱动方式的 mobx 是最佳的解决方案，我们可以通过 observable data + control component 来实现双向同步的 UI 组件。这样就解决了一个字段同步的问题。
同样，当表单复杂以后，我们更倾向于使用树形结构来管理我们的表单数据。
综上，我们选用了 mobx-state-tree 作为底层框架，来对表单的数据进行管理。
同时，我们使用 MSTForm 对 mobx-state-tree 进行扩展，使得每一个数据节点（叶子节点）都从一个 value，变成了带有 ui 状态的对象。
总结一下，MSTForm 是一个用 树形结构 对表单数据进行管理，并使得每一个数据项（即叶子节点）拥有 ui 状态（disabled、readonly、validator、hasError、errorMessage等等）的解决方案。
select #  对于 MSTForm 来说，最重要的 api 就是 select，select 会返回一个 MSTFormField，MSTFormField 是通过代理模式实现的对原叶子节点封装的带有 ui 状态的操作对象。
编程模式的转变 #  带我们使用 MSTForm 对 表单数据进行封装后，我们会发现，以前针对 ui 层面的操作，现在都会被转化为针对数据状态的操作，即我们提升了数据状态的层级，以更加纯净的方式来书写代码，而数据状态 和 真正 ui 层面的更新，则被封装到了更底层的 Level 中。
从而，我们实现了从 面向UI编程 到 面向数据状态编程 的过度。</description>
    </item>
    
    <item>
      <title>修改Menu中的Button</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/menu-button/menu-%E4%BF%AE%E6%94%B9button/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/menu-button/menu-%E4%BF%AE%E6%94%B9button/</guid>
      <description>向Menu中添加Button #  此攻略会向你介绍如何往查看态的menu中加一个按钮
已有按钮添加到menu中 #  class xxFormPresenter extends EasyBizFormPresenter { protected getMenuOptions(): MenuOptions { const menus = super.getMenuOptions().menus; // 删改menus数组  return menus; } } 在这里修改menus数组就可以了。
可以直接往里面添加按钮。也可能要根据权限、是不是变更单等条件过滤掉一些按钮。</description>
    </item>
    
    <item>
      <title>列表中显示虚拟字段列</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E5%88%97%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E5%88%97%E8%A1%A8/</guid>
      <description>配置虚拟字段 #  列表方案是按一定的条件查出一个列表。这个条件在我们的系统中就是“查询方案”。
我们查询数据是通过 gql 实现的，查询方案最终会转化为 criteriaStr。
 进入到开发包中的列表方案。通过 + 加号，就可以添加不同的查询条件。   列表方案都是针对一个entity的，所以查询方案也是针对这个entity的。添加的查询条件根据entity上是否存在field分为两种情况。 其中显示项就是entity上已经存在的field，就是下图这样的。 而虚拟字段就是entity上没有你想要的field作为条件。 需要注意。在这个配置界面，“显示名称”需要先填写英文，确定以后再改成中文，因为我们需要“字段名称”是英文，要在后面的开发中用到。而在最初的配置中的“显示名称”会作为“字段名称”，且字段名称不能修改。 参照和枚举根据需要选择即可。
虚拟字段的代码开发 #  每个查询条件在最后都会转化成 criteriaStr 片段，最后组装成一个大的 criteriaStr 。对于非虚拟字段，可以通过通用的方式去处理的。虚拟字段需要我们写代码来转化为 criteriaStr 。
首先，假设你已经配置好了一个虚拟字段abc。然后就要在goServer上对它进行处理了。
找到目录trek/services/query-list/middlewares/entities，看有没有你的entity的目录，如果没有就创建一个。这里以budget-control-rule-set为例 需要index.go文件和各个虚拟字段.go文件。 index.go文件如下： 每个虚拟字段需要在这里声明。
虚拟字段.go 这里是 rule-remarks.go ： 把这里面的 ruleRemarks 都替换成你的自定义的字段（比如abc）。
  12行，声明字段用来接收查询的值。
  27行，存储查询的值。枚举会传过来选择的枚举的id，字符串就是字符串本体，区间就会有两个值。
  字符串、枚举：   区间：     33行是查询语句。根据自己的业务，会不一样，它会作为该虚拟字段的子criteriaStr拼到完整的criteriaStr中。
  </description>
    </item>
    
    <item>
      <title>功能权限</title>
      <link>https://zxp-77hub.github.io/docs/common/%E5%8A%9F%E8%83%BD%E6%9D%83%E9%99%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E5%8A%9F%E8%83%BD%E6%9D%83%E9%99%90/</guid>
      <description>实现 #  使用下面的代码就可以做到查看功能权限
import { checkAuth } from &amp;#39;@root/func-auth&amp;#39;; import { FunctionAuthActionType } from &amp;#39;@metadata&amp;#39;; checkAuth(EN_Project, FunctionAuthActionType.View) checkAuth方法 #  checkAuth方法的参数：
   参数 描述     resourceId 资源id   actionType 权限类型，有新增、查看、导出、打印等等    resourceId可能是entityId，也可能是另外定义的resourceId，在文件packages/athena-gen/src/entity-constants/ResourceConstants.ts中。具体是哪个需要和后端确认。
actionType的定义在文件apps/link/node_modules/@q7/metadata/src/declare/constants.ts中。摘录到下面。
/** * 功能权限 Action 集合 */ export enum FunctionAuthActionType { // 新增  Add = &amp;#39;add&amp;#39;, // 查看  View = &amp;#39;view&amp;#39;, // 修改  Update = &amp;#39;update&amp;#39;, // 删除  Delete = &amp;#39;delete&amp;#39;, // 输出  Export = &amp;#39;export&amp;#39;, // 打印  Print = &amp;#39;print&amp;#39;, // 作废  Abort = &amp;#39;abort&amp;#39;, // 弃审  Unapprove = &amp;#39;unapprove&amp;#39;, // 审评  Approve = &amp;#39;approve&amp;#39;, // 执行  Execute = &amp;#39;execute&amp;#39;, // 挂起  Suspend = &amp;#39;suspend&amp;#39;, // 取消挂起  CancelSuspend = &amp;#39;cancelSuspend&amp;#39;, // 关闭  Close = &amp;#39;close&amp;#39;, // 打开  Open = &amp;#39;open&amp;#39;, // 预览  Preview = &amp;#39;preview&amp;#39;, // 附件上传  AttachemetUpload = &amp;#39;attachemetUpload&amp;#39;, // 附件删除  AttachmentDelete = &amp;#39;attachmentDelete&amp;#39;, // 附件预览  AttachmentView = &amp;#39;attachmentView&amp;#39;, // 发布  Publish = &amp;#39;publish&amp;#39;, // 设置  Setup = &amp;#39;setup&amp;#39;, // 变更  Change = &amp;#39;change&amp;#39;, } </description>
    </item>
    
    <item>
      <title>如何做详设</title>
      <link>https://zxp-77hub.github.io/docs/design/%E5%A6%82%E4%BD%95%E5%81%9A%E8%AF%A6%E8%AE%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/design/%E5%A6%82%E4%BD%95%E5%81%9A%E8%AF%A6%E8%AE%BE/</guid>
      <description>一个功能如何实现？
 改旧的功能  原来怎么实现的 数据从自哪个entity、哪个字段？进行了哪些拼装、组合、转换？   新的功能  公共的支持吗？  用过吗？  怎么用？     非标的吗？如何设计？  如何管理状态、数据？ 数据从自哪个entity、哪个字段？需要拼装、组合、转换吗？ 有哪些数据需要展示？ 哪些数据分给哪个组件？ 组件  能使用哪些公共组件？ 组件需要的参数 内部需要管理状态吗？   保存数据时需要转换数据吗？ 回显时需要转换数据吗？      </description>
    </item>
    
    <item>
      <title>导出</title>
      <link>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E5%AF%BC%E5%87%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/list-guide/%E8%99%9A%E6%8B%9F%E5%AD%97%E6%AE%B5/%E5%AF%BC%E5%87%BA/</guid>
      <description>适用场景：列表中有虚拟字段、自定义渲染的字段
参考：trek/services/query-list/middlewares/entities/budget-model/report-expression.go
其中的ReportExpression是打印和导出时用到的sql，</description>
    </item>
    
    <item>
      <title>接口</title>
      <link>https://zxp-77hub.github.io/docs/common/%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E6%8E%A5%E5%8F%A3/</guid>
      <description>前端不能直接调用后端提供的rest接口，必须前端请求go，go在请求后端
一、在 go 上申明后端接口地址 #  在文件 trek/urls/url.go 中声明接口地址
 位置 trek/urls/url.yaml
 二. 然后控制台进入 app/script 目录 执行 sh gen.sh 命令 #  sh gen.sh 系统会根据定义的接口申明 在 trek/urls/url.go 上自动生成
 先声明变量。找你相关的代码块，或者自己创建于给代码块，在其中创建变量。  赋值为后端接口地址。在RefreshUrls方法内，将刚刚的变量赋值。  注：这两步是 gen 根据 url.yaml 自动生成，不用手动操作
三. 添加 go 的接口 #   文件路径 trek/web/controllers/web-controllers/transparent/index.go
 第一部分，声明一个接口
 声明go接口的方法（post、get等） 前端访问go接口的url，如果url中包含参数用花括号 处理方法的名字  第二部分，实现方法处理接口
 拿到url中参数，请求后端接口 刚刚设置的后端接口地址的变量  四. 前端调用接口 #   文件路径 apps/link/src/api/urls.ts
 在这个文件里找到自己的entity，如果没有就创建一个，在其中声明一个字段作为接口地址（就是第三步的2）。 然后就可以调接口了，要使用 import client from &#39;@client&#39;;</description>
    </item>
    
    <item>
      <title>数据权限</title>
      <link>https://zxp-77hub.github.io/docs/common/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/</guid>
      <description>前端的gql默认是会按数据权限过滤的。
如果想忽略数据权限的话，需要在option中加contextObject参数，当这个参数是不在数据权限范围内的实体时，就表示忽略数据权限。
所以这里以ignoreDataAuth字符串为参数，来达到忽略权限的目的。
1 2 3 4 5  const dataLoader = new DataLoader(EN_BudgetPlan, [&amp;#39;id&amp;#39;], { criteriaStr: `projectId=&amp;#39;${this.projectId}&amp;#39;`, sorts: [{ name: &amp;#39;createdTime&amp;#39;, isDesending: true }], contextObject: &amp;#39;ignoreDataAuth&amp;#39;, } as IDataLoaderQueryOptions);   </description>
    </item>
    
    <item>
      <title>新建一个MenuButton</title>
      <link>https://zxp-77hub.github.io/docs/form-guide/menu-button/menu-%E6%96%B0%E5%BB%BAbutton/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/form-guide/menu-button/menu-%E6%96%B0%E5%BB%BAbutton/</guid>
      <description>向Menu中添加Button #  此攻略会向你介绍如何往查看态表单的menu中加一个按钮
新建一个menu按钮 #  按下面的步骤就可以创建一个按钮，并把它加到menu中
 按钮的名字 按钮的Creator函数 声明按钮 声明分组 添加到menu中  给搞一个名字 #  在 apps/link/src/solutions/biz-form/page/menu-buttons/declare.ts 文件中在BizFormMenuButtons对象声明按钮的 id 。
搞Creator函数创建按钮 #  export const ProjectBudgetCreator = () =&amp;gt; { return { id: BizFormMenuButtons.ProjectBudget, render: () =&amp;gt; { return ( &amp;lt;React.Fragment&amp;gt; &amp;lt;ProjectBudgetButton key={BizFormMenuButtons.ProjectBudget} /&amp;gt; &amp;lt;/React.Fragment&amp;gt; ); }, }; }; 其中的React组件需要自己实现，主要是一个Button组件。要注意模块启用、权限。
声明按钮 #  有了id和creator函数，就可以声明按钮了。 在 apps/link/src/solutions/biz-form/page/menu-buttons/index.tsx 文件中声明了所有menu按钮的Creator函数。你新创建的按钮也需要在这里声明。
export const buildInMenus = { [BizFormMenuButtons.SourcePicking]: SourcePickCreator, [BizFormMenuButtons.ImportConsumeItem]: ImportConsumeItemCreator, } 声明类型 #  相同类型的按钮会放到同一分组。 在 apps/link/src/solutions/biz-form/page/declare.</description>
    </item>
    
    <item>
      <title>新建开发用租户</title>
      <link>https://zxp-77hub.github.io/docs/other/%E6%96%B0%E5%BB%BA%E7%A7%9F%E6%88%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/other/%E6%96%B0%E5%BB%BA%E7%A7%9F%E6%88%B7/</guid>
      <description>创建新的租户（账号）的方法如下。
 去运维平台查询对应环境地址, 查到对应的 qbos 地址, 一般为对应的 5000 端口  登录地址 http://(qbos对应的ip地址):5000/, 输入密码, temp13 可以用 test1 进行登录  进入租户管理点击新建, 按照需求进行勾选. (注意是否要启用多组织) 多组织和内部交易是一起的, 只有有多组织才有内部交易  然后在租户管理页面进行激活, 输入手机号 测试环境支持随机号码, 输入后,通过 gql 查询验证码, 查询 gql 见下 gql 地址为通过运维平台查询 identity 服务, 一般端口为 9999  { VerificationCode(criteriaStr:&amp;quot;verifyIdFlag in (&#39;注册的手机号&#39;) and to_char(expiredTime, &#39;yyyymmddhh24miss&#39;) &amp;gt;= to_char(CURRENT_TIMESTAMP, &#39;yyyymmddhh24miss&#39;) and isUsed = &#39;false&#39;&amp;quot;){ code expiredTime verifyIdFlag } }  进入对应环境登录界面, 点击激活账号, 输入手机号, 点击获取验证码 输入对应的手机号和验证码, 验证码可以通过 gql 进行查询 成功以后，进入系统，用刚刚的手机号登录，密码是123456，会提示密码简单需要重置。 重置的话，需要手机号接收验证码。验证码可以通过gql查到。 。需要把下面链接中的IP地址替换成你的环境对应的（见下一步）。 这里。找到你的环境，环境会有两个IP，看哪个IP有9999这个服务，把对应的IP放到上面的链接中。  在gql中替换掉你的手机号，就可以查到验证码了。然后重置密码，进入系统就可以了。  </description>
    </item>
    
    <item>
      <title>脱离 form 对entity进行 CRUD</title>
      <link>https://zxp-77hub.github.io/docs/common/entitycrud/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zxp-77hub.github.io/docs/common/entitycrud/</guid>
      <description>有时我们需要新增、修改、删除一条entity的数据。但是这个entity又没有开发对应的form，无法通过表单来完成。这时就要用到EntityCRUDHelper了
import { EntityCRUDHelper } from &amp;#39;@root/solutions/entity-crud&amp;#39;; EntityCRUDHelper.getInstance().update(EN_BudgetAccountDocImport, data) EntityCRUDHelper提供了create/update/delete等几个方法，可以直接基于entity进行crud操作。
   方法 参数 描述     create entityName, data 创建一条记录   update entityName, data 修改一条记录    注意事项 #  entity不能是子表。子表必须通过主表创建。</description>
    </item>
    
  </channel>
</rss>
